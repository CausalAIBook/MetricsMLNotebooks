{
  "cells": [
    {
      "cell_type": "markdown",
      "id": "f02fa044",
      "metadata": {
        "papermill": {
          "duration": 0.012988,
          "end_time": "2022-04-19T09:06:48.772902",
          "exception": false,
          "start_time": "2022-04-19T09:06:48.759914",
          "status": "completed"
        },
        "tags": [],
        "id": "f02fa044"
      },
      "source": [
        "# Inference on Predictive and Causal Effects in High-Dimensional Nonlinear Models"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "23154404",
      "metadata": {
        "papermill": {
          "duration": 0.009437,
          "end_time": "2022-04-19T09:06:48.791895",
          "exception": false,
          "start_time": "2022-04-19T09:06:48.782458",
          "status": "completed"
        },
        "tags": [],
        "id": "23154404"
      },
      "source": [
        "## Impact of 401(k) on  Financial Wealth\n",
        "\n",
        "As a practical illustration of the methods developed in this lecture, we consider estimation of the effect of 401(k) eligibility and participation\n",
        "on accumulated assets. 401(k) plans are pension accounts sponsored by employers. The key problem in determining the effect of participation in 401(k) plans on accumulated assets is saver heterogeneity coupled with the fact that the decision to enroll in a 401(k) is non-random. It is generally recognized that some people have a higher preference for saving than others. It also seems likely that those individuals with high unobserved preference for saving would be most likely to choose to participate in tax-advantaged retirement savings plans and would tend to have otherwise high amounts of accumulated assets. The presence of unobserved savings preferences with these properties then implies that conventional estimates that do not account for saver heterogeneity and endogeneity of participation will be biased upward, tending to overstate the savings effects of 401(k) participation.\n",
        "\n",
        "One can argue that eligibility for enrolling in a 401(k) plan in this data can be taken as exogenous after conditioning on a few observables of which the most important for their argument is income. The basic idea is that, at least around the time 401(k)â€™s initially became available, people were unlikely to be basing their employment decisions on whether an employer offered a 401(k) but would instead focus on income and other aspects of the job."
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "install.packages(\"xtable\")\n",
        "install.packages(\"hdm\")\n",
        "install.packages(\"sandwich\")\n",
        "install.packages(\"ggplot2\")\n",
        "install.packages(\"randomForest\")\n",
        "install.packages(\"glmnet\")\n",
        "install.packages(\"rpart\")\n",
        "install.packages(\"gbm\")\n",
        "\n",
        "library(xtable)\n",
        "library(hdm)\n",
        "library(sandwich)\n",
        "library(ggplot2)\n",
        "library(randomForest)\n",
        "library(data.table)\n",
        "library(glmnet)\n",
        "library(rpart)\n",
        "library(gbm)"
      ],
      "metadata": {
        "id": "KmAkbDiVE7wm"
      },
      "id": "KmAkbDiVE7wm",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "id": "7e23cba0",
      "metadata": {
        "papermill": {
          "duration": 0.009588,
          "end_time": "2022-04-19T09:06:48.810853",
          "exception": false,
          "start_time": "2022-04-19T09:06:48.801265",
          "status": "completed"
        },
        "tags": [],
        "id": "7e23cba0"
      },
      "source": [
        "### Data\n",
        "\n",
        "The raw dataset can be found [here](https://raw.githubusercontent.com/CausalAIBook/MetricsMLNotebooks/main/data/401k.csv).\n",
        "The data set can be loaded from the `hdm` package for R directly by typing:\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c442abdc",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:06:48.833250Z",
          "iopub.status.busy": "2022-04-19T09:06:48.831101Z",
          "iopub.status.idle": "2022-04-19T09:06:49.281559Z",
          "shell.execute_reply": "2022-04-19T09:06:49.279778Z"
        },
        "papermill": {
          "duration": 0.46397,
          "end_time": "2022-04-19T09:06:49.283933",
          "exception": false,
          "start_time": "2022-04-19T09:06:48.819963",
          "status": "completed"
        },
        "tags": [],
        "id": "c442abdc"
      },
      "outputs": [],
      "source": [
        "data(pension)\n",
        "data <- pension\n",
        "dim(data)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e47fa9d3",
      "metadata": {
        "papermill": {
          "duration": 0.009462,
          "end_time": "2022-04-19T09:06:49.302928",
          "exception": false,
          "start_time": "2022-04-19T09:06:49.293466",
          "status": "completed"
        },
        "tags": [],
        "id": "e47fa9d3"
      },
      "source": [
        "See the \"Details\" section on the description of the data set, which can be accessed by\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "00e04b82",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:06:49.394579Z",
          "iopub.status.busy": "2022-04-19T09:06:49.323826Z",
          "iopub.status.idle": "2022-04-19T09:06:49.662556Z",
          "shell.execute_reply": "2022-04-19T09:06:49.660433Z"
        },
        "papermill": {
          "duration": 0.35227,
          "end_time": "2022-04-19T09:06:49.664810",
          "exception": false,
          "start_time": "2022-04-19T09:06:49.312540",
          "status": "completed"
        },
        "tags": [],
        "id": "00e04b82"
      },
      "outputs": [],
      "source": [
        "help(pension)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "24b41e4a",
      "metadata": {
        "papermill": {
          "duration": 0.009357,
          "end_time": "2022-04-19T09:06:49.683784",
          "exception": false,
          "start_time": "2022-04-19T09:06:49.674427",
          "status": "completed"
        },
        "tags": [],
        "id": "24b41e4a"
      },
      "source": [
        "The data consist of 9,915 observations at the household level drawn from the 1991 Survey of Income and Program Participation (SIPP).  All the variables are referred to 1990. We use net financial assets (*net\\_tfa*) as the outcome variable, $Y$,  in our analysis. The net financial assets are computed as the sum of IRA balances, 401(k) balances, checking accounts, saving bonds, other interest-earning accounts, other interest-earning assets, stocks, and mutual funds less non mortgage debts."
      ]
    },
    {
      "cell_type": "markdown",
      "id": "ed9d4e82",
      "metadata": {
        "papermill": {
          "duration": 0.009242,
          "end_time": "2022-04-19T09:06:49.702401",
          "exception": false,
          "start_time": "2022-04-19T09:06:49.693159",
          "status": "completed"
        },
        "tags": [],
        "id": "ed9d4e82"
      },
      "source": [
        "Among the $9915$ individuals, $3682$ are eligible to participate in the program. The variable *e401* indicates eligibility and *p401* indicates participation, respectively."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "63519184",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:06:49.724951Z",
          "iopub.status.busy": "2022-04-19T09:06:49.723401Z",
          "iopub.status.idle": "2022-04-19T09:06:50.327963Z",
          "shell.execute_reply": "2022-04-19T09:06:50.326306Z"
        },
        "papermill": {
          "duration": 0.618528,
          "end_time": "2022-04-19T09:06:50.330218",
          "exception": false,
          "start_time": "2022-04-19T09:06:49.711690",
          "status": "completed"
        },
        "tags": [],
        "id": "63519184"
      },
      "outputs": [],
      "source": [
        "hist_e401 = ggplot(data, aes(x = e401, fill = factor(e401))) + geom_bar()\n",
        "hist_e401"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "823d2628",
      "metadata": {
        "papermill": {
          "duration": 0.009686,
          "end_time": "2022-04-19T09:06:50.349766",
          "exception": false,
          "start_time": "2022-04-19T09:06:50.340080",
          "status": "completed"
        },
        "tags": [],
        "id": "823d2628"
      },
      "source": [
        "Eligibility is highly associated with financial wealth:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "5d8faf9c",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:06:50.372330Z",
          "iopub.status.busy": "2022-04-19T09:06:50.370847Z",
          "iopub.status.idle": "2022-04-19T09:06:50.912011Z",
          "shell.execute_reply": "2022-04-19T09:06:50.910336Z"
        },
        "papermill": {
          "duration": 0.554613,
          "end_time": "2022-04-19T09:06:50.914133",
          "exception": false,
          "start_time": "2022-04-19T09:06:50.359520",
          "status": "completed"
        },
        "tags": [],
        "id": "5d8faf9c"
      },
      "outputs": [],
      "source": [
        "dens_net_tfa = ggplot(data, aes(x = net_tfa, color = factor(e401), fill = factor(e401)) ) +\n",
        "                    geom_density() + xlim(c(-20000, 150000)) +\n",
        "                    facet_wrap(.~e401)\n",
        "\n",
        "dens_net_tfa"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0f4f86a7",
      "metadata": {
        "papermill": {
          "duration": 0.010335,
          "end_time": "2022-04-19T09:06:50.935024",
          "exception": false,
          "start_time": "2022-04-19T09:06:50.924689",
          "status": "completed"
        },
        "tags": [],
        "id": "0f4f86a7"
      },
      "source": [
        "The unconditional APE of e401 is about $19559$:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "836c6af7",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:06:50.959110Z",
          "iopub.status.busy": "2022-04-19T09:06:50.957519Z",
          "iopub.status.idle": "2022-04-19T09:06:50.981194Z",
          "shell.execute_reply": "2022-04-19T09:06:50.979530Z"
        },
        "papermill": {
          "duration": 0.038096,
          "end_time": "2022-04-19T09:06:50.983602",
          "exception": false,
          "start_time": "2022-04-19T09:06:50.945506",
          "status": "completed"
        },
        "tags": [],
        "id": "836c6af7"
      },
      "outputs": [],
      "source": [
        "e1 <- data[data$e401==1,]\n",
        "e0 <- data[data$e401==0,]\n",
        "round(mean(e1$net_tfa)-mean(e0$net_tfa),0)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "22b09926",
      "metadata": {
        "papermill": {
          "duration": 0.01047,
          "end_time": "2022-04-19T09:06:51.004618",
          "exception": false,
          "start_time": "2022-04-19T09:06:50.994148",
          "status": "completed"
        },
        "tags": [],
        "id": "22b09926"
      },
      "source": [
        "Among the $3682$ individuals that  are eligible, $2594$ decided to participate in the program. The unconditional APE of p401 is about $27372$:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e78aaa58",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:06:51.029140Z",
          "iopub.status.busy": "2022-04-19T09:06:51.027462Z",
          "iopub.status.idle": "2022-04-19T09:06:51.052361Z",
          "shell.execute_reply": "2022-04-19T09:06:51.050591Z"
        },
        "papermill": {
          "duration": 0.039305,
          "end_time": "2022-04-19T09:06:51.054616",
          "exception": false,
          "start_time": "2022-04-19T09:06:51.015311",
          "status": "completed"
        },
        "tags": [],
        "id": "e78aaa58"
      },
      "outputs": [],
      "source": [
        "p1 <- data[data$p401==1,]\n",
        "p0 <- data[data$p401==0,]\n",
        "round(mean(p1$net_tfa)-mean(p0$net_tfa),0)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e0af3c81",
      "metadata": {
        "papermill": {
          "duration": 0.010831,
          "end_time": "2022-04-19T09:06:51.076114",
          "exception": false,
          "start_time": "2022-04-19T09:06:51.065283",
          "status": "completed"
        },
        "tags": [],
        "id": "e0af3c81"
      },
      "source": [
        "As discussed, these estimates are biased since they do not account for saver heterogeneity and endogeneity of participation."
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# outcome variable\n",
        "y <- data[,'net_tfa']\n",
        "# treatment variable\n",
        "D <- data[,'e401']\n",
        "D2 <- data[,\"p401\"]\n",
        "D3 <- data[,\"a401\"]\n",
        "\n",
        "columns_to_drop <- c('e401', 'p401', 'a401', 'tw', 'tfa', 'net_tfa', 'tfa_he',\n",
        "               'hval', 'hmort', 'hequity',\n",
        "               'nifa', 'net_nifa', 'net_n401', 'ira',\n",
        "               'dum91', 'icat', 'ecat', 'zhat',\n",
        "               'i1', 'i2', 'i3', 'i4', 'i5', 'i6', 'i7',\n",
        "               'a1', 'a2', 'a3', 'a4', 'a5')\n",
        "\n",
        "# covariates\n",
        "X <- data[, !(names(data) %in% columns_to_drop)]"
      ],
      "metadata": {
        "id": "1hBrSMQGzZBR"
      },
      "id": "1hBrSMQGzZBR",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Constructing the controls\n",
        "X_formula = \"~ 0 + poly(age, 6, raw=TRUE) + poly(inc, 8, raw=TRUE) + poly(educ, 4, raw=TRUE) + poly(fsize, 2, raw=TRUE) + male + marr + twoearn + db + pira + hown\"\n",
        "X = as.data.table(model.frame(X_formula, pension))\n",
        "head(X)"
      ],
      "metadata": {
        "id": "DD0Hwcb6z4u5"
      },
      "id": "DD0Hwcb6z4u5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Estimating the ATE of 401(k) Eligibility on Net Financial Assets"
      ],
      "metadata": {
        "id": "MZThhulbKA9W"
      },
      "id": "MZThhulbKA9W"
    },
    {
      "cell_type": "markdown",
      "source": [
        "We are interested in valid estimators of the average treatment effect of `e401` and `p401` on `net_tfa`. We start using ML approaches to estimate the function $g_0$ and $m_0$ in the following PLR model:"
      ],
      "metadata": {
        "id": "UuYqY89D0pvs"
      },
      "id": "UuYqY89D0pvs"
    },
    {
      "cell_type": "markdown",
      "source": [
        "\\begin{eqnarray}\n",
        " &  Y = D\\theta_0 + g_0(X) + \\zeta,  &  E[\\zeta \\mid D,X]= 0,\\\\\n",
        " & D = m_0(X) +  V,   &  E[V \\mid X] = 0.\n",
        "\\end{eqnarray}"
      ],
      "metadata": {
        "id": "vEAeB2ih0r8B"
      },
      "id": "vEAeB2ih0r8B"
    },
    {
      "cell_type": "markdown",
      "id": "cde447aa",
      "metadata": {
        "papermill": {
          "duration": 0.011129,
          "end_time": "2022-04-19T09:07:12.117442",
          "exception": false,
          "start_time": "2022-04-19T09:07:12.106313",
          "status": "completed"
        },
        "tags": [],
        "id": "cde447aa"
      },
      "source": [
        "## Partially Linear Regression Models (PLR)"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "DML2.for.PLM <- function(x, d, y, dreg, yreg, nfold=3, method = \"regression\") {\n",
        "  nobs <- nrow(x) #number of observations\n",
        "  foldid <- rep.int(1:nfold,times = ceiling(nobs/nfold))[sample.int(nobs)] #define folds indices\n",
        "  I <- split(1:nobs, foldid)  #split observation indices into folds\n",
        "  ytil <- dtil <- rep(NA, nobs)\n",
        "  cat(\"fold: \")\n",
        "  for(b in 1:length(I)){\n",
        "\n",
        "    if (method == \"regression\") {\n",
        "        dfit <- dreg(x[-I[[b]],], d[-I[[b]]]) #take a fold out\n",
        "        yfit <- yreg(x[-I[[b]],], y[-I[[b]]]) # take a foldt out\n",
        "        dhat <- predict(dfit, x[I[[b]],], type=\"response\") #predict the left-out fold\n",
        "        yhat <- predict(yfit, x[I[[b]],], type=\"response\") #predict the left-out fold\n",
        "        dtil[I[[b]]] <- (d[I[[b]]] - dhat) #record residual for the left-out fold\n",
        "        ytil[I[[b]]] <- (y[I[[b]]] - yhat) #record residial for the left-out fold\n",
        "    } else if (method == \"randomforest\") {\n",
        "        dfit <- dreg(x[-I[[b]],], as.factor(d)[-I[[b]]]) #take a fold out\n",
        "        yfit <- yreg(x[-I[[b]],], y[-I[[b]]]) # take a fold out\n",
        "        dhat <- predict(dfit, x[I[[b]],], type=\"prob\")[,2] #predict the left-out fold\n",
        "        yhat <- predict(yfit, x[I[[b]],], type=\"response\") #predict the left-out fold\n",
        "        dtil[I[[b]]] <- (d[I[[b]]] - dhat) #record residual for the left-out fold\n",
        "        ytil[I[[b]]] <- (y[I[[b]]] - yhat) #record residial for the left-out fold\n",
        "    } else if (method == \"decisiontrees\") {\n",
        "        dfit <- dreg(x[-I[[b]],], as.factor(d)[-I[[b]]]) #take a fold out\n",
        "        yfit <- yreg(x[-I[[b]],], y[-I[[b]]]) # take a fold out\n",
        "        dhat <- predict(dfit, x[I[[b]],])[,2] #predict the left-out fold\n",
        "        yhat <- predict(yfit, x[I[[b]],]) #predict the left-out fold\n",
        "        dtil[I[[b]]] <- (d[I[[b]]] - dhat) #record residual for the left-out fold\n",
        "        ytil[I[[b]]] <- (y[I[[b]]] - yhat) #record residial for the left-out fold\n",
        "    } else if (method == \"boostedtrees\") {\n",
        "        dfit <- dreg(x[-I[[b]],], d[-I[[b]]]) #take a fold out\n",
        "        yfit <- yreg(x[-I[[b]],], y[-I[[b]]]) # take a fold out\n",
        "        dhat <- predict(dfit, x[I[[b]],], type=\"response\") #predict the left-out fold\n",
        "        yhat <- predict(yfit, x[I[[b]],], type=\"response\") #predict the left-out fold\n",
        "        dtil[I[[b]]] <- (d[I[[b]]] - dhat) #record residual for the left-out fold\n",
        "        ytil[I[[b]]] <- (y[I[[b]]] - yhat) #record residial for the left-out fold\n",
        "    }\n",
        "    cat(b,\" \")\n",
        "\n",
        "  }\n",
        "  rfit <- lm(ytil ~ dtil)    #estimate the main parameter by regressing one residual on the other\n",
        "  coef.est <- coef(rfit)[2]  #extract coefficient\n",
        "  se <- sqrt(vcovHC(rfit)[2,2]) #record robust standard error\n",
        "  cat(sprintf(\"\\ncoef (se) = %g (%g)\\n\", coef.est , se))  #printing output\n",
        "  return( list(coef.est =coef.est , se=se, dtil=dtil, ytil=ytil) ) #save output and residuals\n",
        "}\n"
      ],
      "metadata": {
        "id": "tqFlcClUNr9Z"
      },
      "id": "tqFlcClUNr9Z",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "summaryPLR <- function(point, stderr, resD, resy, name) {\n",
        "  data <- data.frame(\n",
        "    estimate = point, # point estimate\n",
        "    stderr = stderr, # standard error\n",
        "    lower = point - 1.96 * stderr, # lower end of 95% confidence interval\n",
        "    upper = point + 1.96 * stderr, # upper end of 95% confidence interval\n",
        "    `rmse y` = sqrt(mean(resy^2)), # RMSE of model that predicts outcome y\n",
        "    `rmse D` = sqrt(mean(resD^2)), # RMSE of model that predicts treatment D\n",
        "    `accuracy D` = mean(abs(resD) < 0.5)# binary classification accuracy of model for D\n",
        "  )\n",
        "  rownames(data) <- name\n",
        "  return(data)\n",
        "}"
      ],
      "metadata": {
        "id": "sS0P4CVySjDP"
      },
      "id": "sS0P4CVySjDP",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "source": [
        "#### Double Lasso with Cross-Fitting"
      ],
      "metadata": {
        "id": "pdGcjnngSn5Q"
      },
      "id": "pdGcjnngSn5Q"
    },
    {
      "cell_type": "code",
      "source": [
        "# DML with LassoCV\n",
        "set.seed(123)\n",
        "cat(sprintf(\"\\nDML with Lasso CV \\n\"))\n",
        "\n",
        "dreg.lasso.cv <- function(x,d){ cv.glmnet(x, d, family=\"gaussian\", alpha=1, nfolds=5)}\n",
        "yreg.lasso.cv <- function(x,y){ cv.glmnet(x, y, family=\"gaussian\", alpha=1, nfolds=5)}\n",
        "\n",
        "DML2.results <- DML2.for.PLM(as.matrix(X), D, y, dreg.lasso.cv, yreg.lasso.cv, nfold=5)\n",
        "\n",
        "sum.lasso.cv <- summaryPLR(DML2.results$coef.est, DML2.results$se, DML2.results$dtil, DML2.results$ytil, name = 'LassoCV')\n",
        "tableplr <- data.frame()\n",
        "tableplr <- rbind(sum.lasso.cv)\n",
        "tableplr"
      ],
      "metadata": {
        "id": "LOVuR5QO1bkB"
      },
      "id": "LOVuR5QO1bkB",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Because residuals are output, reconstruct fitted values for use in ensemble\n",
        "dhat.lasso <- D - DML2.results$dtil\n",
        "yhat.lasso <- y - DML2.results$ytil"
      ],
      "metadata": {
        "id": "KatOw36Z0ghO"
      },
      "id": "KatOw36Z0ghO",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "source": [
        "#### Using a $\\ell_2$ Penalized Logistic Regression for D\n",
        "\n",
        "Note we are using the $\\ell_2$ penalty here. You can use the $\\ell_1$ penalty as well, but computation will take longer."
      ],
      "metadata": {
        "id": "4wvLEj12SpDf"
      },
      "id": "4wvLEj12SpDf"
    },
    {
      "cell_type": "code",
      "source": [
        "# DML with Lasso/Logistic\n",
        "set.seed(123)\n",
        "cat(sprintf(\"\\nDML with Lasso/Logistic \\n\"))\n",
        "\n",
        "dreg.logistic.cv <- function(x,d){cv.glmnet(x, d, family=\"binomial\", alpha=0, nfolds=5)}\n",
        "yreg.lasso.cv <- function(x,y){cv.glmnet(x, y, family=\"gaussian\", alpha=1, nfolds=5)}\n",
        "\n",
        "DML2.results <- DML2.for.PLM(as.matrix(X), D, y, dreg.logistic.cv, yreg.lasso.cv, nfold=5)\n",
        "sum.lasso_logistic.cv <- summaryPLR(DML2.results$coef.est, DML2.results$se, DML2.results$dtil, DML2.results$ytil, name = 'LassoCV/LogisticCV')\n",
        "tableplr <- rbind(tableplr, sum.lasso_logistic.cv)\n",
        "tableplr"
      ],
      "metadata": {
        "id": "b9Nvp5ZlSuwB"
      },
      "id": "b9Nvp5ZlSuwB",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Because residuals are output, reconstruct fitted values for use in ensemble\n",
        "dhat.lasso_logistic <- D - DML2.results$dtil\n",
        "yhat.lasso_logistic <- y - DML2.results$ytil"
      ],
      "metadata": {
        "id": "hJqMdcZV05lr"
      },
      "id": "hJqMdcZV05lr",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "source": [
        "#### Random Forests"
      ],
      "metadata": {
        "id": "txyv6IDXSu64"
      },
      "id": "txyv6IDXSu64"
    },
    {
      "cell_type": "code",
      "source": [
        "# DML with Random Forest\n",
        "set.seed(123)\n",
        "cat(sprintf(\"\\nDML with Random Forest \\n\"))\n",
        "\n",
        "dreg.rf <- function(x,d){randomForest(x, d, ntree=1000, nodesize=10)}  #ML method=Forest\n",
        "yreg.rf <- function(x,y){randomForest(x, y, ntree=1000, nodesize=10)}  #ML method=Forest\n",
        "\n",
        "DML2.results <- DML2.for.PLM(as.matrix(X), D, y, dreg.rf, yreg.rf, nfold=5, method = \"randomforest\")\n",
        "sum.rf <- summaryPLR(DML2.results$coef.est, DML2.results$se, DML2.results$dtil, DML2.results$ytil, name = 'Random Forest')\n",
        "tableplr <- rbind(tableplr, sum.rf)\n",
        "tableplr"
      ],
      "metadata": {
        "id": "nt0oTHTfSwMr"
      },
      "id": "nt0oTHTfSwMr",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Because residuals are output, reconstruct fitted values for use in ensemble\n",
        "dhat.rf <- D - DML2.results$dtil\n",
        "yhat.rf <- y - DML2.results$ytil"
      ],
      "metadata": {
        "id": "TG476dPX1BI_"
      },
      "id": "TG476dPX1BI_",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "source": [
        "#### Decision Trees"
      ],
      "metadata": {
        "id": "k8EFP-w_SwXZ"
      },
      "id": "k8EFP-w_SwXZ"
    },
    {
      "cell_type": "code",
      "source": [
        "# DML with Decision Trees\n",
        "set.seed(123)\n",
        "cat(sprintf(\"\\nDML with Decision Trees \\n\"))\n",
        "\n",
        "dreg.tr <- function(x,d){rpart(as.formula(\"D~.\"), cbind(data.frame(D=d),x), method = \"class\", minbucket=10, cp = 0.001)}\n",
        "yreg.tr <- function(x,y){rpart(as.formula(\"y~.\"), cbind(data.frame(y=y),x), minbucket=10, cp = 0.001)}\n",
        "\n",
        "DML2.results <- DML2.for.PLM(X, D, y, dreg.tr, yreg.tr, nfold=5, method = \"decisiontrees\") # decision tree takes in X as dataframe, not matrix/array\n",
        "sum.tr <- summaryPLR(DML2.results$coef.est, DML2.results$se, DML2.results$dtil, DML2.results$ytil, name = 'Decision Trees')\n",
        "tableplr <- rbind(tableplr, sum.tr)\n",
        "tableplr"
      ],
      "metadata": {
        "id": "3Nu4daQRSyRb"
      },
      "id": "3Nu4daQRSyRb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Because residuals are output, reconstruct fitted values for use in ensemble\n",
        "dhat.tr <- D - DML2.results$dtil\n",
        "yhat.tr <- y - DML2.results$ytil"
      ],
      "metadata": {
        "id": "RnCGwVbN1KJJ"
      },
      "id": "RnCGwVbN1KJJ",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "source": [
        "\n",
        "Ideally, we would do (semi) cross-fitting with AutoML in order to find good first-stage models and re-run DML with these models. Unfortunately this is not easy to do in R. In the case of semi cross-fitting, we can use R's H20 AutoML trained on the entire training set $y\\sim X$, $D \\sim X$, $Z\\sim X$ to determine the best model (eg ensemble), but H20 does not allow you to extract said model so we can re-use that in DML."
      ],
      "metadata": {
        "id": "jODHt0hjntdP"
      },
      "id": "jODHt0hjntdP"
    },
    {
      "cell_type": "markdown",
      "source": [
        "#### Boosted Trees"
      ],
      "metadata": {
        "id": "SaPGNW0SSxWk"
      },
      "id": "SaPGNW0SSxWk"
    },
    {
      "cell_type": "code",
      "source": [
        "# DML with Boosted Trees\n",
        "set.seed(123)\n",
        "cat(sprintf(\"\\nDML with Boosted Trees \\n\"))\n",
        "\n",
        "# NB: early stopping cannot easily be implemented with gbm\n",
        "## set n.trees = best, where best <- gbm.perf(dreg.boost, plot.it = FALSE)\n",
        "dreg.boost  <- function(x,d){gbm(as.formula(\"D~.\"), cbind(data.frame(D=d),x), distribution= \"bernoulli\", interaction.depth=2, n.trees=100, shrinkage=.1)}\n",
        "yreg.boost  <- function(x,y){gbm(as.formula(\"y~.\"), cbind(data.frame(y=y),x), distribution= \"gaussian\", interaction.depth=2, n.trees=100, shrinkage=.1)}\n",
        "\n",
        "# passing these through regression as type=\"response\", and D should not be factor!\n",
        "DML2.results = DML2.for.PLM(X, D, y, dreg.boost, yreg.boost, nfold=5, method = \"boostedtrees\")\n",
        "sum.boost <- summaryPLR(DML2.results$coef.est, DML2.results$se, DML2.results$dtil, DML2.results$ytil, name = 'Boosted Trees')\n",
        "tableplr <- rbind(tableplr, sum.boost)\n",
        "tableplr"
      ],
      "metadata": {
        "id": "Ekg5qeEOSxep"
      },
      "id": "Ekg5qeEOSxep",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Because residuals are output, reconstruct fitted values for use in ensemble\n",
        "dhat.boost <- D - DML2.results$dtil\n",
        "yhat.boost <- y - DML2.results$ytil"
      ],
      "metadata": {
        "id": "WSyqSd5Z1hne"
      },
      "id": "WSyqSd5Z1hne",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Ensembles"
      ],
      "metadata": {
        "id": "7UZphpPS10Hz"
      },
      "id": "7UZphpPS10Hz"
    },
    {
      "cell_type": "markdown",
      "source": [
        "Boosted trees give the best RMSE for both Y and D, so the ensemble based on choosing the best performing prediction rule is identical to boosting in this case."
      ],
      "metadata": {
        "id": "Hqsqpgs6C4fJ"
      },
      "id": "Hqsqpgs6C4fJ"
    },
    {
      "cell_type": "code",
      "source": [
        "# Best fit is boosted trees for both D and Y\n",
        "\n",
        "sum.best <- summaryPLR(DML2.results$coef.est, DML2.results$se, DML2.results$dtil, DML2.results$ytil, name = 'Best')\n",
        "tableplr <- rbind(tableplr, sum.best)\n",
        "tableplr"
      ],
      "metadata": {
        "id": "gDrZqZXR12hA"
      },
      "id": "gDrZqZXR12hA",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "source": [
        "We'll form a model average with unconstrained least squares weights."
      ],
      "metadata": {
        "id": "pG8mmrQw2GRC"
      },
      "id": "pG8mmrQw2GRC"
    },
    {
      "cell_type": "code",
      "source": [
        "# Least squares model average\n",
        "\n",
        "ma.dtil <- lm(D~dhat.lasso+dhat.lasso_logistic+dhat.rf+dhat.tr+dhat.boost)$residuals\n",
        "ma.ytil <- lm(y~yhat.lasso+yhat.lasso_logistic+yhat.rf+yhat.tr+yhat.boost)$residuals\n",
        "\n",
        "rfit <- lm(ma.ytil ~ ma.dtil)    #estimate the main parameter by regressing one residual on the other\n",
        "coef.est <- coef(rfit)[2]  #extract coefficient\n",
        "se <- sqrt(vcovHC(rfit)[2,2]) #record robust standard error\n",
        "\n",
        "sum.ma <- summaryPLR(coef.est, se, ma.dtil, ma.ytil, name = 'Model Average')\n",
        "tableplr <- rbind(tableplr, sum.ma)\n",
        "tableplr\n"
      ],
      "metadata": {
        "id": "Pkg7pw5h2N0z"
      },
      "id": "Pkg7pw5h2N0z",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "id": "67fa5873",
      "metadata": {
        "papermill": {
          "duration": 0.013657,
          "end_time": "2022-04-19T09:10:00.718448",
          "exception": false,
          "start_time": "2022-04-19T09:10:00.704791",
          "status": "completed"
        },
        "tags": [],
        "id": "67fa5873"
      },
      "source": [
        "## Interactive Regression Model (IRM)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "86393e4c",
      "metadata": {
        "papermill": {
          "duration": 0.013488,
          "end_time": "2022-04-19T09:10:00.745538",
          "exception": false,
          "start_time": "2022-04-19T09:10:00.732050",
          "status": "completed"
        },
        "tags": [],
        "id": "86393e4c"
      },
      "source": [
        "Next, we consider estimation of average treatment effects when treatment effects are fully heterogeneous:"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "830bb508",
      "metadata": {
        "papermill": {
          "duration": 0.013695,
          "end_time": "2022-04-19T09:10:00.772756",
          "exception": false,
          "start_time": "2022-04-19T09:10:00.759061",
          "status": "completed"
        },
        "tags": [],
        "id": "830bb508"
      },
      "source": [
        " \\begin{eqnarray}\\label{eq: HetPL1}\n",
        " & Y  = g_0(D, X) + U,  &  \\quad E[U \\mid X, D]= 0,\\\\\n",
        "  & D  = m_0(X) + V,  & \\quad  E[V\\mid X] = 0.\n",
        "\\end{eqnarray}"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "9e5ec32b",
      "metadata": {
        "papermill": {
          "duration": 0.013592,
          "end_time": "2022-04-19T09:10:00.799889",
          "exception": false,
          "start_time": "2022-04-19T09:10:00.786297",
          "status": "completed"
        },
        "tags": [],
        "id": "9e5ec32b"
      },
      "source": [
        "To reduce the disproportionate impact of extreme propensity score weights in the interactive model\n",
        "we trim the propensity scores which are close to the bounds."
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "DML2.for.IRM <- function(x, d, y, dreg, yreg0, yreg1, trimming=0.01, nfold=5, method=\"regression\") {\n",
        "  yhat0 <- rep(0, length(y))\n",
        "  yhat1 <- rep(0, length(y))\n",
        "  Dhat <- rep(0, length(d))\n",
        "\n",
        "  nobs <- nrow(x) #number of observations\n",
        "  foldid <- rep.int(1:nfold,times = ceiling(nobs/nfold))[sample.int(nobs)] #define folds indices\n",
        "  I <- split(1:nobs, foldid)  #split observation indices into folds\n",
        "  ytil <- dtil <- rep(NA, nobs)\n",
        "\n",
        "  cat(\"fold: \")\n",
        "  for(b in 1:length(I)){\n",
        "\n",
        "    # define helpful variables\n",
        "    Dnotb = d[-I[[b]]]\n",
        "    Xb = X[I[[b]],]\n",
        "    Xnotb = X[-I[[b]],]\n",
        "\n",
        "    # training dfs subsetted on the -I[[b]] fold\n",
        "    XD0 = X[-I[[b]],][d[-I[[b]]]==0]\n",
        "    yD0 = y[-I[[b]]][d[-I[[b]]]==0]\n",
        "    XD1 = X[-I[[b]],][d[-I[[b]]]==1]\n",
        "    yD1 = y[-I[[b]]][d[-I[[b]]]==1]\n",
        "\n",
        "    if (method == \"regression\") {\n",
        "        yfit0 <- yreg0(as.matrix(XD0), yD0)\n",
        "        yfit1 <- yreg1(as.matrix(XD1), yD1)\n",
        "        yhat0[I[[b]]] <- predict(yfit0, as.matrix(Xb)) # default is type = \"response\" for glmnet family gaussian\n",
        "        yhat1[I[[b]]] <- predict(yfit1, as.matrix(Xb))\n",
        "    } else if (method == \"randomforest\") {\n",
        "        yfit0 <- yreg0(XD0, yD0)\n",
        "        yfit1 <- yreg1(XD1, yD1)\n",
        "        yhat0[I[[b]]] <- predict(yfit0, Xb) # default is type = \"response\" for rf\n",
        "        yhat1[I[[b]]] <- predict(yfit1, Xb)\n",
        "    } else if (method == \"decisiontrees\") {\n",
        "        yfit0 <- yreg0(XD0, yD0)\n",
        "        yfit1 <- yreg1(XD1, yD1)\n",
        "        yhat0[I[[b]]] <- predict(yfit0, Xb) # default is type = \"vector\" for decision\n",
        "        yhat1[I[[b]]] <- predict(yfit1, Xb)\n",
        "    } else if (method == \"boostedtrees\") {\n",
        "        yfit0 <- yreg0(as.data.frame(XD0), yD0)\n",
        "        yfit1 <- yreg1(as.data.frame(XD1), yD1)\n",
        "        yhat0[I[[b]]] <- predict(yfit0, Xb) # default is type = \"response\" for boosted\n",
        "        yhat1[I[[b]]] <- predict(yfit1, Xb)\n",
        "    }\n",
        "\n",
        "    # propensity scores:\n",
        "    if (method == \"regression\"){\n",
        "      Dfit_b <- dreg(as.matrix(Xnotb), Dnotb)\n",
        "      Dhat_b <- predict(Dfit_b, as.matrix(Xb), type=\"response\") # default is type=\"link\" for family binomial!\n",
        "    } else if (method == \"randomforest\") {\n",
        "      Dfit_b <- dreg(Xnotb, as.factor(Dnotb))\n",
        "      Dhat_b <- predict(Dfit_b, Xb, type = \"prob\")[,2]\n",
        "    } else if (method == \"decisiontrees\") {\n",
        "      Dfit_b <- dreg(Xnotb, Dnotb)\n",
        "      Dhat_b <- predict(Dfit_b, Xb)[,2]\n",
        "    } else if (method == \"boostedtrees\") {\n",
        "      Dfit_b <- dreg(as.data.frame(Xnotb), Dnotb)\n",
        "      Dhat_b <- predict(Dfit_b, Xb, type=\"response\")\n",
        "    }\n",
        "    Dhat_b <- pmax(pmin(Dhat_b, 1 - trimming), trimming) # trimming so scores are between [trimming, (1-trimming)]\n",
        "    Dhat[I[[b]]] <- Dhat_b\n",
        "\n",
        "\n",
        "    cat(b,\" \")\n",
        "  }\n",
        "\n",
        "  # Prediction of treatment and outcome for observed instrument\n",
        "  yhat <- yhat0 * (1 - D) + yhat1 * D\n",
        "  # residuals\n",
        "  ytil <- y-yhat\n",
        "  dtil <- D-Dhat\n",
        "  # doubly robust quantity for every sample\n",
        "  drhat <- yhat1 - yhat0 + (y-yhat)* (D/Dhat - (1 - D)/(1 - Dhat))\n",
        "  coef.est <- mean(drhat)\n",
        "  vari <- var(drhat)\n",
        "  se <- sqrt(vari/nrow(X))\n",
        "  cat(\"point\", coef.est)\n",
        "  cat(\"se\", se)\n",
        "  return(list(coef.est = coef.est, se = se, ytil = ytil, dtil = dtil, drhat = drhat, yhat0 = yhat0, yhat1 = yhat1, dhat = Dhat, yhat = yhat))\n",
        "}"
      ],
      "metadata": {
        "id": "-hCmnqC-N0nS"
      },
      "id": "-hCmnqC-N0nS",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "summaryIRM <- function(coef.est, se, ytil, dtil, drhat, name) {\n",
        "  summary_data <- data.frame(estimate = coef.est,  # point estimate\n",
        "                             se = se,  # standard error\n",
        "                             lower = coef.est - 1.96 * se,  # lower end of 95% confidence interval\n",
        "                             upper = coef.est + 1.96 * se,  # upper end of 95% confidence interval\n",
        "                             rmse_y = sqrt(mean(ytil^2)),  # res of model that predicts outcome y\n",
        "                             rmse_D = sqrt(mean(dtil^2)),  # res of model that predicts treatment D\n",
        "                             accuracy_D = mean(abs(dtil) < 0.5)  # binary classification accuracy of model for D\n",
        "  )\n",
        "  row.names(summary_data) <- name\n",
        "  return(summary_data)\n",
        "}"
      ],
      "metadata": {
        "id": "bCj1D8_MSg09"
      },
      "id": "bCj1D8_MSg09",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "source": [
        "#### Repeat analysis in the IRM setting."
      ],
      "metadata": {
        "id": "6mCdfifchkgZ"
      },
      "id": "6mCdfifchkgZ"
    },
    {
      "cell_type": "code",
      "source": [
        "# DML with Lasso/Logistic\n",
        "set.seed(123)\n",
        "cat(sprintf(\"\\nDML with LassoCV/Logistic \\n\"))\n",
        "\n",
        "dreg.lasso.cv <- function(x,d){cv.glmnet(x, d, family=\"binomial\", alpha=0, nfolds=5)}\n",
        "yreg0.lasso.cv <- function(x,y){cv.glmnet(x, y, family=\"gaussian\", alpha=1, nfolds=5)}\n",
        "yreg1.lasso.cv <- function(x,y){cv.glmnet(x, y, family=\"gaussian\", alpha=1, nfolds=5)}\n",
        "\n",
        "DML2.results <- DML2.for.IRM(X, D, y, dreg.lasso.cv, yreg0.lasso.cv, yreg1.lasso.cv, nfold=5) # more folds seems to help stabilize finite sample performance\n",
        "sum.lasso.cv <- summaryIRM(DML2.results$coef.est, DML2.results$se, DML2.results$ytil, DML2.results$dtil, DML2.results$drhat, name = 'LassoCVLogistic')\n",
        "tableirm <- data.frame()\n",
        "tableirm <- rbind(sum.lasso.cv)\n",
        "tableirm\n",
        "\n",
        "yhat0.lasso <- DML2.results$yhat0\n",
        "yhat1.lasso <- DML2.results$yhat1\n",
        "dhat.lasso <- DML2.results$dhat\n",
        "yhat.lasso <- DML2.results$yhat"
      ],
      "metadata": {
        "id": "AUiHMoNTvo-m"
      },
      "id": "AUiHMoNTvo-m",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# DML with Random Forest\n",
        "set.seed(123)\n",
        "cat(sprintf(\"\\nDML with Random Forest \\n\"))\n",
        "\n",
        "dreg.rf <- function(x,d){randomForest(x, d, ntree=1000, nodesize=10)}  #ML method=Forest\n",
        "yreg0.rf <- function(x,y){randomForest(x, y, ntree=1000, nodesize=10)}  #ML method=Forest\n",
        "yreg1.rf <- function(x,y){randomForest(x, y, ntree=1000, nodesize=10)}  #ML method=Forest\n",
        "\n",
        "\n",
        "DML2.results <- DML2.for.IRM(as.matrix(X), D, y, dreg.rf, yreg0.rf, yreg1.rf, nfold=5, method = \"randomforest\")\n",
        "sum.rf <- summaryIRM(DML2.results$coef.est, DML2.results$se, DML2.results$ytil, DML2.results$dtil, DML2.results$drhat, name = 'Random Forest')\n",
        "tableirm <- rbind(tableirm, sum.rf)\n",
        "tableirm\n",
        "\n",
        "yhat0.rf <- DML2.results$yhat0\n",
        "yhat1.rf <- DML2.results$yhat1\n",
        "dhat.rf <- DML2.results$dhat\n",
        "yhat.rf <- DML2.results$yhat"
      ],
      "metadata": {
        "id": "JPABXLYyvyqy"
      },
      "id": "JPABXLYyvyqy",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# DML with Decision Trees\n",
        "set.seed(123)\n",
        "cat(sprintf(\"\\nDML with Decision Trees \\n\"))\n",
        "\n",
        "dreg.tr <- function(x,d){rpart(as.formula(\"D~.\"), cbind(data.frame(D=d),x), method = \"class\", minbucket=10, cp = 0.001)}\n",
        "yreg0.tr <- function(x,y){rpart(as.formula(\"y~.\"), cbind(data.frame(y=y),x), minbucket=10, cp = 0.001)}\n",
        "yreg1.tr <- function(x,y){rpart(as.formula(\"y~.\"), cbind(data.frame(y=y),x), minbucket=10, cp = 0.001)}\n",
        "\n",
        "DML2.results <- DML2.for.IRM(X, D, y, dreg.tr, yreg0.tr, yreg1.tr, nfold=5, method = \"decisiontrees\")\n",
        "sum.tr <- summaryIRM(DML2.results$coef.est, DML2.results$se, DML2.results$ytil, DML2.results$dtil, DML2.results$drhat, name = 'Decision Trees')\n",
        "tableirm <- rbind(tableirm, sum.tr)\n",
        "tableirm\n",
        "\n",
        "yhat0.tr <- DML2.results$yhat0\n",
        "yhat1.tr <- DML2.results$yhat1\n",
        "dhat.tr <- DML2.results$dhat\n",
        "yhat.tr <- DML2.results$yhat"
      ],
      "metadata": {
        "id": "SukZCfEbvyzC"
      },
      "id": "SukZCfEbvyzC",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# DML with Boosted Trees\n",
        "set.seed(123)\n",
        "cat(sprintf(\"\\nDML with Boosted Trees \\n\"))\n",
        "\n",
        "# NB: early stopping cannot easily be implemented with gbm\n",
        "## set n.trees = best, where best <- gbm.perf(dreg.boost, plot.it = FALSE)\n",
        "dreg.boost  <- function(x,d){gbm(as.formula(\"D~.\"), cbind(data.frame(D=d),x), distribution= \"bernoulli\", interaction.depth=2, n.trees=100, shrinkage=.1)}\n",
        "yreg0.boost  <- function(x,y){gbm(as.formula(\"y~.\"), cbind(data.frame(y=y),x), distribution= \"gaussian\", interaction.depth=2, n.trees=100, shrinkage=.1)}\n",
        "yreg1.boost  <- function(x,y){gbm(as.formula(\"y~.\"), cbind(data.frame(y=y),x), distribution= \"gaussian\", interaction.depth=2, n.trees=100, shrinkage=.1)}\n",
        "\n",
        "# passing these through regression as type=\"response\", and D should not be factor!\n",
        "DML2.results = DML2.for.IRM(X, D, y, dreg.boost, yreg0.boost, yreg1.boost, nfold=5, method = \"boostedtrees\")\n",
        "sum.boost <- summaryIRM(DML2.results$coef.est, DML2.results$se, DML2.results$ytil, DML2.results$dtil, DML2.results$drhat, name = 'Boosted Trees')\n",
        "tableirm <- rbind(tableirm, sum.boost)\n",
        "tableirm\n",
        "\n",
        "yhat0.boost <- DML2.results$yhat0\n",
        "yhat1.boost <- DML2.results$yhat1\n",
        "dhat.boost <- DML2.results$dhat\n",
        "yhat.boost <- DML2.results$yhat"
      ],
      "metadata": {
        "id": "bTfgiCabvy6f"
      },
      "id": "bTfgiCabvy6f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Ensembles\n",
        "\n",
        "# Best\n",
        "# We'll look at model that does best for Y overall. Could also use different model for Y0 and Y1\n",
        "# Here, the best performance for Y is the random forest and for D the boosted tree\n",
        "\n",
        "# residuals\n",
        "ytil <- y-yhat.rf\n",
        "dtil <- D-dhat.boost\n",
        "# doubly robust quantity for every sample\n",
        "drhat <- yhat1.rf - yhat0.rf + (y-yhat.rf)* (D/dhat.boost - (1 - D)/(1 - dhat.boost))\n",
        "coef.est <- mean(drhat)\n",
        "vari <- var(drhat)\n",
        "se <- sqrt(vari/nrow(X))\n",
        "\n",
        "sum.best <- summaryIRM(coef.est, se, ytil, dtil, drhat, name = 'Best')\n",
        "tableirm <- rbind(tableirm, sum.best)\n",
        "tableirm"
      ],
      "metadata": {
        "id": "7rxqwK-R4Z2q"
      },
      "id": "7rxqwK-R4Z2q",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "source": [
        "# Least squares model average\n",
        "# We'll look at weights that do best job for Y overall. Could also use different weights for Y0 and Y1\n",
        "\n",
        "ma.dw <- lm(D~dhat.lasso+dhat.rf+dhat.tr+dhat.boost)$coef\n",
        "ma.yw <- lm(y~yhat.lasso+yhat.rf+yhat.tr+yhat.boost)$coef\n",
        "\n",
        "Dhats <- cbind(as.matrix(rep(1,nrow(X))),dhat.lasso,dhat.rf,dhat.tr,dhat.boost)\n",
        "Y0s <- cbind(as.matrix(rep(1,nrow(X))),yhat0.lasso,yhat0.rf,yhat0.tr,yhat0.boost)\n",
        "Y1s <- cbind(as.matrix(rep(1,nrow(X))),yhat1.lasso,yhat1.rf,yhat1.tr,yhat1.boost)\n",
        "\n",
        "dhat <- Dhats%*%as.matrix(ma.dw)\n",
        "yhat0 <- Y0s%*%as.matrix(ma.yw)\n",
        "yhat1 <- Y1s%*%as.matrix(ma.yw)\n",
        "\n",
        "# Prediction of treatment and outcome for observed instrument\n",
        "yhat <- yhat0 * (1 - D) + yhat1 * D\n",
        "# residuals\n",
        "ytil <- y-yhat\n",
        "dtil <- D-dhat\n",
        "# doubly robust quantity for every sample\n",
        "drhat <- yhat1 - yhat0 + (y-yhat)* (D/dhat - (1 - D)/(1 - dhat))\n",
        "coef.est <- mean(drhat)\n",
        "vari <- var(drhat)\n",
        "se <- sqrt(vari/nrow(X))\n",
        "\n",
        "sum.ma <- summaryIRM(coef.est, se, ytil, dtil, drhat, name = 'Model Average')\n",
        "tableirm <- rbind(tableirm, sum.ma)\n",
        "tableirm\n"
      ],
      "metadata": {
        "id": "0-c3NI0fCfqg"
      },
      "id": "0-c3NI0fCfqg",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "id": "01de9f24",
      "metadata": {
        "papermill": {
          "duration": 0.010725,
          "end_time": "2022-04-19T09:06:51.098483",
          "exception": false,
          "start_time": "2022-04-19T09:06:51.087758",
          "status": "completed"
        },
        "tags": [],
        "id": "01de9f24"
      },
      "source": [
        "## Double ML package"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6cdc366f",
      "metadata": {
        "papermill": {
          "duration": 0.010679,
          "end_time": "2022-04-19T09:06:51.119780",
          "exception": false,
          "start_time": "2022-04-19T09:06:51.109101",
          "status": "completed"
        },
        "tags": [],
        "id": "6cdc366f"
      },
      "source": [
        "We are interested in valid estimators of the average treatment effect of `e401` and `p401` on `net_tfa`. There exist nice packages out there that can help us do our estimation with the simple call of a function. Such packages include `EconML` (Python) and `DoubleML` (Python and R).\n",
        "\n",
        "We run through PLR and IRM using `DoubleML` below to illustrate. The `DoubleML` package internally builds on `mlr3`. We use the meta package `mlr3` to generate predictions with machine learning methods. A comprehensive introduction and description of the `mlr3` package is provided in the [mlr3book](https://mlr3book.mlr-org.com/). A list of all learners that you can use in `mlr3` can be found [here](https://mlr3extralearners.mlr-org.com/articles/learners/list_learners.html). The entry in the columns *mlr3 Package* and *Packages* indicate which packages must be installed/loaded in your R session.\n",
        "\n",
        "You find additional information about `DoubleML` on the package on the package website https://docs.doubleml.org/ and the R documentation page https://docs.doubleml.org/r/stable/."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2846a36a",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:06:51.144230Z",
          "iopub.status.busy": "2022-04-19T09:06:51.142682Z",
          "iopub.status.idle": "2022-04-19T09:07:11.366508Z",
          "shell.execute_reply": "2022-04-19T09:07:11.364676Z"
        },
        "papermill": {
          "duration": 20.239271,
          "end_time": "2022-04-19T09:07:11.369618",
          "exception": false,
          "start_time": "2022-04-19T09:06:51.130347",
          "status": "completed"
        },
        "tags": [],
        "id": "2846a36a"
      },
      "outputs": [],
      "source": [
        "install.packages(\"DoubleML\")\n",
        "install.packages(\"mlr3learners\")\n",
        "install.packages(\"mlr3\")\n",
        "install.packages(\"data.table\")\n",
        "install.packages(\"randomForest\")\n",
        "install.packages(\"ranger\")\n",
        "\n",
        "library(DoubleML)\n",
        "library(mlr3learners)\n",
        "library(mlr3)\n",
        "library(data.table)\n",
        "library(randomForest)\n",
        "library(ranger)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "2a141248",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:07:12.009260Z",
          "iopub.status.busy": "2022-04-19T09:07:12.007545Z",
          "iopub.status.idle": "2022-04-19T09:07:12.092289Z",
          "shell.execute_reply": "2022-04-19T09:07:12.090545Z"
        },
        "papermill": {
          "duration": 0.100382,
          "end_time": "2022-04-19T09:07:12.094585",
          "exception": false,
          "start_time": "2022-04-19T09:07:11.994203",
          "status": "completed"
        },
        "tags": [],
        "id": "2a141248"
      },
      "outputs": [],
      "source": [
        "# Constructing the data (as DoubleMLData)\n",
        "formula_flex = \"net_tfa ~ e401 + poly(age, 6, raw=TRUE) + poly(inc, 8, raw=TRUE) + poly(educ, 4, raw=TRUE) + poly(fsize, 2, raw=TRUE) + marr + twoearn + db + pira + hown\"\n",
        "model_flex = as.data.table(model.frame(formula_flex, pension))\n",
        "x_cols = colnames(model_flex)[-c(1,2)]\n",
        "data_ml = DoubleMLData$new(model_flex, y_col = \"net_tfa\", d_cols = \"e401\", x_cols=x_cols)\n",
        "\n",
        "\n",
        "p <- dim(model_flex)[2]-2\n",
        "p\n",
        "\n",
        "# complex model with two-way interactions\n",
        "#data_interactions = fetch_401k(polynomial_features = TRUE, instrument = FALSE)\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "2e1c9339",
      "metadata": {
        "papermill": {
          "duration": 0.010825,
          "end_time": "2022-04-19T09:07:11.938062",
          "exception": false,
          "start_time": "2022-04-19T09:07:11.927237",
          "status": "completed"
        },
        "tags": [],
        "id": "2e1c9339"
      },
      "source": [
        "As mentioned, in the tutorial we use the meta package `mlr3` to generate predictions with machine learning methods. A comprehensive introduction and description of the `mlr3` package is provided in the [mlr3book](https://mlr3book.mlr-org.com/). A list of all learners that you can use in `mlr3` can be found [here](https://mlr3extralearners.mlr-org.com/articles/learners/list_learners.html). The entry in the columns *mlr3 Package* and *Packages* indicate which packages must be installed/loaded in your R session."
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Partially Linear Regression Models (PLR)"
      ],
      "metadata": {
        "id": "Cwmd7ELXKeIg"
      },
      "id": "Cwmd7ELXKeIg"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "a48e367d",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:07:12.188025Z",
          "iopub.status.busy": "2022-04-19T09:07:12.186501Z",
          "iopub.status.idle": "2022-04-19T09:07:34.643694Z",
          "shell.execute_reply": "2022-04-19T09:07:34.641926Z"
        },
        "papermill": {
          "duration": 22.473331,
          "end_time": "2022-04-19T09:07:34.646865",
          "exception": false,
          "start_time": "2022-04-19T09:07:12.173534",
          "status": "completed"
        },
        "tags": [],
        "id": "a48e367d"
      },
      "outputs": [],
      "source": [
        "# Estimating the PLR\n",
        "lgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\n",
        "lasso <- lrn(\"regr.cv_glmnet\",nfolds = 5, s = \"lambda.min\")\n",
        "lasso_class <- lrn(\"classif.cv_glmnet\", nfolds = 5, s = \"lambda.min\")\n",
        "\n",
        "dml_plr <- DoubleMLPLR$new(data_ml, ml_l = lasso, ml_m = lasso_class, n_folds=5)\n",
        "dml_plr$fit(store_predictions=TRUE)\n",
        "dml_plr$summary()\n",
        "lasso_plr <- dml_plr$coef\n",
        "lasso_std_plr <- dml_plr$se"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "135275dc",
      "metadata": {
        "papermill": {
          "duration": 0.011132,
          "end_time": "2022-04-19T09:07:34.670166",
          "exception": false,
          "start_time": "2022-04-19T09:07:34.659034",
          "status": "completed"
        },
        "tags": [],
        "id": "135275dc"
      },
      "source": [
        "Let us check the predictive performance of this model."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e6d83bbe",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:07:34.695782Z",
          "iopub.status.busy": "2022-04-19T09:07:34.694101Z",
          "iopub.status.idle": "2022-04-19T09:07:34.716746Z",
          "shell.execute_reply": "2022-04-19T09:07:34.714842Z"
        },
        "papermill": {
          "duration": 0.038389,
          "end_time": "2022-04-19T09:07:34.719637",
          "exception": false,
          "start_time": "2022-04-19T09:07:34.681248",
          "status": "completed"
        },
        "tags": [],
        "id": "e6d83bbe"
      },
      "outputs": [],
      "source": [
        "dml_plr$params_names()\n",
        "g_hat <- as.matrix(dml_plr$predictions$ml_l) # predictions of g_o\n",
        "m_hat <- as.matrix(dml_plr$predictions$ml_m) # predictions of m_o"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "32c894fa",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:07:34.745097Z",
          "iopub.status.busy": "2022-04-19T09:07:34.743570Z",
          "iopub.status.idle": "2022-04-19T09:07:34.771488Z",
          "shell.execute_reply": "2022-04-19T09:07:34.769302Z"
        },
        "papermill": {
          "duration": 0.043342,
          "end_time": "2022-04-19T09:07:34.774113",
          "exception": false,
          "start_time": "2022-04-19T09:07:34.730771",
          "status": "completed"
        },
        "tags": [],
        "id": "32c894fa"
      },
      "outputs": [],
      "source": [
        "# cross-fitted RMSE: outcome\n",
        "y <- as.matrix(pension$net_tfa) # true observations\n",
        "theta <- as.numeric(dml_plr$coef) # estimated regression coefficient\n",
        "d <- as.matrix(pension$e401)\n",
        "predictions_y <- as.matrix(d*theta)+g_hat # predictions for y\n",
        "lasso_y_rmse <- sqrt(mean((y-predictions_y)^2))\n",
        "lasso_y_rmse"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "da5b9334",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:07:34.800143Z",
          "iopub.status.busy": "2022-04-19T09:07:34.798474Z",
          "iopub.status.idle": "2022-04-19T09:07:34.826393Z",
          "shell.execute_reply": "2022-04-19T09:07:34.824605Z"
        },
        "papermill": {
          "duration": 0.04333,
          "end_time": "2022-04-19T09:07:34.828718",
          "exception": false,
          "start_time": "2022-04-19T09:07:34.785388",
          "status": "completed"
        },
        "tags": [],
        "id": "da5b9334"
      },
      "outputs": [],
      "source": [
        "# cross-fitted RMSE: treatment\n",
        "d <- as.matrix(pension$e401)\n",
        "lasso_d_rmse <- sqrt(mean((d-m_hat)^2))\n",
        "lasso_d_rmse\n",
        "\n",
        "# cross-fitted ce: treatment\n",
        "mean(ifelse(m_hat > 0.5, 1, 0) != d)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c1481527",
      "metadata": {
        "papermill": {
          "duration": 0.011351,
          "end_time": "2022-04-19T09:07:34.851558",
          "exception": false,
          "start_time": "2022-04-19T09:07:34.840207",
          "status": "completed"
        },
        "tags": [],
        "id": "c1481527"
      },
      "source": [
        "Then, we repeat this procedure for various machine learning methods."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "dac2d0fc",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:07:34.878296Z",
          "iopub.status.busy": "2022-04-19T09:07:34.876743Z",
          "iopub.status.idle": "2022-04-19T09:08:35.899658Z",
          "shell.execute_reply": "2022-04-19T09:08:35.896930Z"
        },
        "papermill": {
          "duration": 61.046861,
          "end_time": "2022-04-19T09:08:35.910116",
          "exception": false,
          "start_time": "2022-04-19T09:07:34.863255",
          "status": "completed"
        },
        "tags": [],
        "id": "dac2d0fc"
      },
      "outputs": [],
      "source": [
        "# Random Forest\n",
        "lgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\n",
        "randomForest <- lrn(\"regr.ranger\")\n",
        "randomForest_class <- lrn(\"classif.ranger\")\n",
        "\n",
        "dml_plr <- DoubleMLPLR$new(data_ml, ml_l = randomForest, ml_m = randomForest_class, n_folds=5)\n",
        "dml_plr$fit(store_predictions=TRUE) # set store_predictions=TRUE to evaluate the model\n",
        "dml_plr$summary()\n",
        "forest_plr <- dml_plr$coef\n",
        "forest_std_plr <- dml_plr$se"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "c7c614e6",
      "metadata": {
        "papermill": {
          "duration": 0.011382,
          "end_time": "2022-04-19T09:08:35.932891",
          "exception": false,
          "start_time": "2022-04-19T09:08:35.921509",
          "status": "completed"
        },
        "tags": [],
        "id": "c7c614e6"
      },
      "source": [
        "We can compare the accuracy of this model to the model that has been estimated with lasso."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "f8af1a74",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:08:35.993655Z",
          "iopub.status.busy": "2022-04-19T09:08:35.992094Z",
          "iopub.status.idle": "2022-04-19T09:08:36.034450Z",
          "shell.execute_reply": "2022-04-19T09:08:36.032502Z"
        },
        "papermill": {
          "duration": 0.092847,
          "end_time": "2022-04-19T09:08:36.037154",
          "exception": false,
          "start_time": "2022-04-19T09:08:35.944307",
          "status": "completed"
        },
        "tags": [],
        "id": "f8af1a74"
      },
      "outputs": [],
      "source": [
        "# Evaluation predictions\n",
        "g_hat <- as.matrix(dml_plr$predictions$ml_l) # predictions of g_o\n",
        "m_hat <- as.matrix(dml_plr$predictions$ml_m) # predictions of m_o\n",
        "theta <- as.numeric(dml_plr$coef) # estimated regression coefficient\n",
        "predictions_y <- as.matrix(d*theta)+g_hat # predictions for y\n",
        "forest_y_rmse <- sqrt(mean((y-predictions_y)^2))\n",
        "forest_y_rmse\n",
        "\n",
        "# cross-fitted RMSE: treatment\n",
        "forest_d_rmse <- sqrt(mean((d-m_hat)^2))\n",
        "forest_d_rmse\n",
        "\n",
        "# cross-fitted ce: treatment\n",
        "mean(ifelse(m_hat > 0.5, 1, 0) != d)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "61a94dff",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:08:36.064976Z",
          "iopub.status.busy": "2022-04-19T09:08:36.063494Z",
          "iopub.status.idle": "2022-04-19T09:08:37.268375Z",
          "shell.execute_reply": "2022-04-19T09:08:37.266452Z"
        },
        "papermill": {
          "duration": 1.221303,
          "end_time": "2022-04-19T09:08:37.271202",
          "exception": false,
          "start_time": "2022-04-19T09:08:36.049899",
          "status": "completed"
        },
        "tags": [],
        "id": "61a94dff"
      },
      "outputs": [],
      "source": [
        "# Trees\n",
        "lgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\n",
        "\n",
        "trees <- lrn(\"regr.rpart\")\n",
        "trees_class <- lrn(\"classif.rpart\")\n",
        "\n",
        "dml_plr <- DoubleMLPLR$new(data_ml, ml_l = trees, ml_m = trees_class, n_folds=5)\n",
        "dml_plr$fit(store_predictions=TRUE)\n",
        "dml_plr$summary()\n",
        "tree_plr <- dml_plr$coef\n",
        "tree_std_plr <- dml_plr$se\n",
        "\n",
        "# Evaluation predictions\n",
        "g_hat <- as.matrix(dml_plr$predictions$ml_l) # predictions of g_o\n",
        "m_hat <- as.matrix(dml_plr$predictions$ml_m) # predictions of m_o\n",
        "theta <- as.numeric(dml_plr$coef) # estimated regression coefficient\n",
        "predictions_y <- as.matrix(d*theta)+g_hat # predictions for y\n",
        "tree_y_rmse <- sqrt(mean((y-predictions_y)^2))\n",
        "tree_y_rmse\n",
        "\n",
        "# cross-fitted RMSE: treatment\n",
        "tree_d_rmse <- sqrt(mean((d-m_hat)^2))\n",
        "tree_d_rmse\n",
        "\n",
        "# cross-fitted ce: treatment\n",
        "mean(ifelse(m_hat > 0.5, 1, 0) != d)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "885c94eb",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:08:37.299832Z",
          "iopub.status.busy": "2022-04-19T09:08:37.297991Z",
          "iopub.status.idle": "2022-04-19T09:09:58.069060Z",
          "shell.execute_reply": "2022-04-19T09:09:58.066595Z"
        },
        "papermill": {
          "duration": 80.788944,
          "end_time": "2022-04-19T09:09:58.072665",
          "exception": false,
          "start_time": "2022-04-19T09:08:37.283721",
          "status": "completed"
        },
        "tags": [],
        "id": "885c94eb"
      },
      "outputs": [],
      "source": [
        "# needed to run boosting\n",
        "remotes::install_github(\"mlr-org/mlr3extralearners\")\n",
        "install.packages(\"mlr3extralearners\")\n",
        "install.packages(\"mboost\")\n",
        "library(mlr3extralearners)\n",
        "library(mboost)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "0372eefe",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:09:58.106809Z",
          "iopub.status.busy": "2022-04-19T09:09:58.105019Z",
          "iopub.status.idle": "2022-04-19T09:10:00.492368Z",
          "shell.execute_reply": "2022-04-19T09:10:00.490644Z"
        },
        "papermill": {
          "duration": 2.404791,
          "end_time": "2022-04-19T09:10:00.494687",
          "exception": false,
          "start_time": "2022-04-19T09:09:58.089896",
          "status": "completed"
        },
        "tags": [],
        "id": "0372eefe"
      },
      "outputs": [],
      "source": [
        "# Boosting\n",
        "boost<- lrn(\"regr.glmboost\")\n",
        "boost_class <- lrn(\"classif.glmboost\")\n",
        "\n",
        "dml_plr <- DoubleMLPLR$new(data_ml, ml_l = boost, ml_m = boost_class, n_folds=5)\n",
        "dml_plr$fit(store_predictions=TRUE)\n",
        "dml_plr$summary()\n",
        "boost_plr <- dml_plr$coef\n",
        "boost_std_plr <- dml_plr$se\n",
        "\n",
        "# Evaluation predictions\n",
        "g_hat <- as.matrix(dml_plr$predictions$ml_l) # predictions of g_o\n",
        "m_hat <- as.matrix(dml_plr$predictions$ml_m) # predictions of m_o\n",
        "theta <- as.numeric(dml_plr$coef) # estimated regression coefficient\n",
        "predictions_y <- as.matrix(d*theta)+g_hat # predictions for y\n",
        "boost_y_rmse <- sqrt(mean((y-predictions_y)^2))\n",
        "boost_y_rmse\n",
        "\n",
        "# cross-fitted RMSE: treatment\n",
        "boost_d_rmse <- sqrt(mean((d-m_hat)^2))\n",
        "boost_d_rmse\n",
        "\n",
        "# cross-fitted ce: treatment\n",
        "mean(ifelse(m_hat > 0.5, 1, 0) != d)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "ffa1e35a",
      "metadata": {
        "papermill": {
          "duration": 0.013161,
          "end_time": "2022-04-19T09:10:00.521404",
          "exception": false,
          "start_time": "2022-04-19T09:10:00.508243",
          "status": "completed"
        },
        "tags": [],
        "id": "ffa1e35a"
      },
      "source": [
        "Let's sum up the results:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d322c48a",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:10:00.551222Z",
          "iopub.status.busy": "2022-04-19T09:10:00.549553Z",
          "iopub.status.idle": "2022-04-19T09:10:00.613728Z",
          "shell.execute_reply": "2022-04-19T09:10:00.611934Z"
        },
        "papermill": {
          "duration": 0.081341,
          "end_time": "2022-04-19T09:10:00.615953",
          "exception": false,
          "start_time": "2022-04-19T09:10:00.534612",
          "status": "completed"
        },
        "tags": [],
        "id": "d322c48a"
      },
      "outputs": [],
      "source": [
        "table <- matrix(0, 4, 4)\n",
        "table[1,1:4]   <- c(lasso_plr,forest_plr,tree_plr,boost_plr)\n",
        "table[2,1:4]   <- c(lasso_std_plr,forest_std_plr,tree_std_plr,boost_std_plr)\n",
        "table[3,1:4]   <- c(lasso_y_rmse,forest_y_rmse,tree_y_rmse,boost_y_rmse)\n",
        "table[4,1:4]   <- c(lasso_d_rmse,forest_d_rmse,tree_d_rmse,boost_d_rmse)\n",
        "rownames(table) <- c(\"Estimate\",\"Std.Error\",\"RMSE Y\",\"RMSE D\")\n",
        "colnames(table) <- c(\"Lasso\",\"Random Forest\",\"Trees\",\"Boosting\")\n",
        "tab<- xtable(table, digits = 2)\n",
        "tab"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "e8e9ffc8",
      "metadata": {
        "papermill": {
          "duration": 0.013424,
          "end_time": "2022-04-19T09:10:00.642931",
          "exception": false,
          "start_time": "2022-04-19T09:10:00.629507",
          "status": "completed"
        },
        "tags": [],
        "id": "e8e9ffc8"
      },
      "source": [
        "The best model with lowest RMSE is the PLR model estimated via lasso (or boosting based on the RSME Y). It gives the following estimate:"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "33fcc2b4",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:10:00.673204Z",
          "iopub.status.busy": "2022-04-19T09:10:00.671479Z",
          "iopub.status.idle": "2022-04-19T09:10:00.688330Z",
          "shell.execute_reply": "2022-04-19T09:10:00.686511Z"
        },
        "papermill": {
          "duration": 0.034272,
          "end_time": "2022-04-19T09:10:00.690621",
          "exception": false,
          "start_time": "2022-04-19T09:10:00.656349",
          "status": "completed"
        },
        "tags": [],
        "id": "33fcc2b4"
      },
      "outputs": [],
      "source": [
        "lasso_plr"
      ]
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Interactive Regression Model (IRM)"
      ],
      "metadata": {
        "id": "Ebrv1spfKWxH"
      },
      "id": "Ebrv1spfKWxH"
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9a7410a9",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:10:00.830326Z",
          "iopub.status.busy": "2022-04-19T09:10:00.828843Z",
          "iopub.status.idle": "2022-04-19T09:10:18.931564Z",
          "shell.execute_reply": "2022-04-19T09:10:18.929808Z"
        },
        "papermill": {
          "duration": 18.121031,
          "end_time": "2022-04-19T09:10:18.934550",
          "exception": false,
          "start_time": "2022-04-19T09:10:00.813519",
          "status": "completed"
        },
        "tags": [],
        "id": "9a7410a9"
      },
      "outputs": [],
      "source": [
        "lgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\n",
        "dml_irm = DoubleMLIRM$new(data_ml, ml_g = lasso,\n",
        "                          ml_m = lasso_class,\n",
        "                          trimming_threshold = 0.01, n_folds=5)\n",
        "dml_irm$fit(store_predictions=TRUE)\n",
        "dml_irm$summary()\n",
        "lasso_irm <- dml_irm$coef\n",
        "lasso_std_irm <- dml_irm$se\n",
        "\n",
        "\n",
        "# predictions\n",
        "dml_irm$params_names()\n",
        "g0_hat <- as.matrix(dml_irm$predictions$ml_g0) # predictions of g_0(D=0, X)\n",
        "g1_hat <- as.matrix(dml_irm$predictions$ml_g1) # predictions of g_0(D=1, X)\n",
        "g_hat <- d*g1_hat+(1-d)*g0_hat # predictions of g_0\n",
        "m_hat <- as.matrix(dml_irm$predictions$ml_m) # predictions of m_o\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "1a34a9e8",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:10:18.965991Z",
          "iopub.status.busy": "2022-04-19T09:10:18.964496Z",
          "iopub.status.idle": "2022-04-19T09:10:18.999103Z",
          "shell.execute_reply": "2022-04-19T09:10:18.997500Z"
        },
        "papermill": {
          "duration": 0.052429,
          "end_time": "2022-04-19T09:10:19.001172",
          "exception": false,
          "start_time": "2022-04-19T09:10:18.948743",
          "status": "completed"
        },
        "tags": [],
        "id": "1a34a9e8"
      },
      "outputs": [],
      "source": [
        "# cross-fitted RMSE: outcome\n",
        "y <- as.matrix(pension$net_tfa) # true observations\n",
        "d <- as.matrix(pension$e401)\n",
        "lasso_y_irm <- sqrt(mean((y-g_hat)^2))\n",
        "lasso_y_irm\n",
        "\n",
        "# cross-fitted RMSE: treatment\n",
        "lasso_d_irm <- sqrt(mean((d-m_hat)^2))\n",
        "lasso_d_irm\n",
        "\n",
        "# cross-fitted ce: treatment\n",
        "mean(ifelse(m_hat > 0.5, 1, 0) != d)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "d0c93355",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:10:19.032688Z",
          "iopub.status.busy": "2022-04-19T09:10:19.031200Z",
          "iopub.status.idle": "2022-04-19T09:11:17.780954Z",
          "shell.execute_reply": "2022-04-19T09:11:17.777618Z"
        },
        "papermill": {
          "duration": 58.769131,
          "end_time": "2022-04-19T09:11:17.784652",
          "exception": false,
          "start_time": "2022-04-19T09:10:19.015521",
          "status": "completed"
        },
        "tags": [],
        "id": "d0c93355"
      },
      "outputs": [],
      "source": [
        "##### forest #####\n",
        "\n",
        "dml_irm = DoubleMLIRM$new(data_ml, ml_g = randomForest,\n",
        "                          ml_m = randomForest_class,\n",
        "                          trimming_threshold = 0.01, n_folds=5)\n",
        "dml_irm$fit(store_predictions=TRUE)\n",
        "dml_irm$summary()\n",
        "forest_irm <- dml_irm$coef\n",
        "forest_std_irm <- dml_plr$se\n",
        "\n",
        "# predictions\n",
        "g0_hat <- as.matrix(dml_irm$predictions$ml_g0) # predictions of g_0(D=0, X)\n",
        "g1_hat <- as.matrix(dml_irm$predictions$ml_g1) # predictions of g_0(D=1, X)\n",
        "g_hat <- d*g1_hat+(1-d)*g0_hat # predictions of g_0\n",
        "m_hat <- as.matrix(dml_irm$predictions$ml_m) # predictions of m_0\n",
        "\n",
        "# cross-fitted RMSE: outcome\n",
        "y <- as.matrix(pension$net_tfa) # true observations\n",
        "d <- as.matrix(pension$e401)\n",
        "forest_y_irm <- sqrt(mean((y-g_hat)^2))\n",
        "forest_y_irm\n",
        "\n",
        "# cross-fitted RMSE: treatment\n",
        "forest_d_irm <- sqrt(mean((d-m_hat)^2))\n",
        "forest_d_irm\n",
        "\n",
        "# cross-fitted ce: treatment\n",
        "mean(ifelse(m_hat > 0.5, 1, 0) != d)\n",
        "\n",
        "##### trees #####\n",
        "\n",
        "dml_irm <- DoubleMLIRM$new(data_ml, ml_g = trees, ml_m = trees_class,\n",
        "                           trimming_threshold = 0.01, n_folds=5)\n",
        "dml_irm$fit(store_predictions=TRUE)\n",
        "dml_irm$summary()\n",
        "tree_irm <- dml_irm$coef\n",
        "tree_std_irm <- dml_irm$se\n",
        "\n",
        "# predictions\n",
        "g0_hat <- as.matrix(dml_irm$predictions$ml_g0) # predictions of g_0(D=0, X)\n",
        "g1_hat <- as.matrix(dml_irm$predictions$ml_g1) # predictions of g_0(D=1, X)\n",
        "g_hat <- d*g1_hat+(1-d)*g0_hat # predictions of g_0\n",
        "m_hat <- as.matrix(dml_irm$predictions$ml_m) # predictions of m_o\n",
        "\n",
        "# cross-fitted RMSE: outcome\n",
        "y <- as.matrix(pension$net_tfa) # true observations\n",
        "d <- as.matrix(pension$e401)\n",
        "tree_y_irm <- sqrt(mean((y-g_hat)^2))\n",
        "tree_y_irm\n",
        "\n",
        "# cross-fitted RMSE: treatment\n",
        "tree_d_irm <- sqrt(mean((d-m_hat)^2))\n",
        "tree_d_irm\n",
        "\n",
        "# cross-fitted ce: treatment\n",
        "mean(ifelse(m_hat > 0.5, 1, 0) != d)\n",
        "\n",
        "\n",
        "##### boosting #####\n",
        "\n",
        "dml_irm <- DoubleMLIRM$new(data_ml, ml_g = boost, ml_m = boost_class,\n",
        "                           trimming_threshold = 0.01, n_folds=5)\n",
        "dml_irm$fit(store_predictions=TRUE)\n",
        "dml_irm$summary()\n",
        "boost_irm <- dml_irm$coef\n",
        "boost_std_irm <- dml_irm$se\n",
        "\n",
        "# predictions\n",
        "g0_hat <- as.matrix(dml_irm$predictions$ml_g0) # predictions of g_0(D=0, X)\n",
        "g1_hat <- as.matrix(dml_irm$predictions$ml_g1) # predictions of g_0(D=1, X)\n",
        "g_hat <- d*g1_hat+(1-d)*g0_hat # predictions of g_0\n",
        "m_hat <- as.matrix(dml_irm$predictions$ml_m) # predictions of m_o\n",
        "\n",
        "# cross-fitted RMSE: outcome\n",
        "y <- as.matrix(pension$net_tfa) # true observations\n",
        "d <- as.matrix(pension$e401)\n",
        "boost_y_irm <- sqrt(mean((y-g_hat)^2))\n",
        "boost_y_irm\n",
        "\n",
        "# cross-fitted RMSE: treatment\n",
        "boost_d_irm <- sqrt(mean((d-m_hat)^2))\n",
        "boost_d_irm\n",
        "\n",
        "# cross-fitted ce: treatment\n",
        "mean(ifelse(m_hat > 0.5, 1, 0) != d)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "bf344442",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:11:17.820803Z",
          "iopub.status.busy": "2022-04-19T09:11:17.819244Z",
          "iopub.status.idle": "2022-04-19T09:11:17.858729Z",
          "shell.execute_reply": "2022-04-19T09:11:17.856801Z"
        },
        "papermill": {
          "duration": 0.059911,
          "end_time": "2022-04-19T09:11:17.861698",
          "exception": false,
          "start_time": "2022-04-19T09:11:17.801787",
          "status": "completed"
        },
        "tags": [],
        "id": "bf344442"
      },
      "outputs": [],
      "source": [
        "table <- matrix(0, 4, 4)\n",
        "table[1,1:4]   <- c(lasso_irm,forest_irm,tree_irm,boost_irm)\n",
        "table[2,1:4]   <- c(lasso_std_irm,forest_std_irm,tree_std_irm,boost_std_irm)\n",
        "table[3,1:4]   <- c(lasso_y_irm,forest_y_irm,tree_y_irm,boost_y_irm)\n",
        "table[4,1:4]   <- c(lasso_d_irm,forest_d_irm,tree_d_irm,boost_d_irm)\n",
        "rownames(table) <- c(\"Estimate\",\"Std.Error\",\"RMSE Y\",\"RMSE D\")\n",
        "colnames(table) <- c(\"Lasso\",\"Random Forest\",\"Trees\",\"Boosting\")\n",
        "tab<- xtable(table, digits = 2)\n",
        "tab"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "cddc45ff",
      "metadata": {
        "papermill": {
          "duration": 0.015454,
          "end_time": "2022-04-19T09:11:17.892511",
          "exception": false,
          "start_time": "2022-04-19T09:11:17.877057",
          "status": "completed"
        },
        "tags": [],
        "id": "cddc45ff"
      },
      "source": [
        "Here, Random Forest gives the best prediction rule for $g_0$ and Lasso the best prediction rule for $m_0$, respectively. Let us fit the IRM model using the best ML method for each equation to get a final estimate for the treatment effect of eligibility."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "9d4b8690",
      "metadata": {
        "execution": {
          "iopub.execute_input": "2022-04-19T09:11:17.926513Z",
          "iopub.status.busy": "2022-04-19T09:11:17.924857Z",
          "iopub.status.idle": "2022-04-19T09:12:00.841438Z",
          "shell.execute_reply": "2022-04-19T09:12:00.838577Z"
        },
        "papermill": {
          "duration": 42.950051,
          "end_time": "2022-04-19T09:12:00.858025",
          "exception": false,
          "start_time": "2022-04-19T09:11:17.907974",
          "status": "completed"
        },
        "tags": [],
        "id": "9d4b8690"
      },
      "outputs": [],
      "source": [
        "lgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\n",
        "dml_irm = DoubleMLIRM$new(data_ml, ml_g = randomForest,\n",
        "                          ml_m = lasso_class,\n",
        "                          trimming_threshold = 0.01, n_folds=5)\n",
        "dml_irm$fit(store_predictions=TRUE)\n",
        "dml_irm$summary()\n",
        "best_irm <- dml_irm$coef\n",
        "best_std_irm <- dml_irm$se"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "92a77dd6",
      "metadata": {
        "papermill": {
          "duration": 0.015461,
          "end_time": "2022-04-19T09:12:00.888702",
          "exception": false,
          "start_time": "2022-04-19T09:12:00.873241",
          "status": "completed"
        },
        "tags": [],
        "id": "92a77dd6"
      },
      "source": [
        "These estimates that flexibly account for confounding are\n",
        "substantially attenuated relative to the baseline estimate (*19559*) that does not account for confounding. They suggest much smaller causal effects of 401(k) eligiblity on financial asset holdings."
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "R",
      "language": "R",
      "name": "ir"
    },
    "language_info": {
      "codemirror_mode": "r",
      "file_extension": ".r",
      "mimetype": "text/x-r-source",
      "name": "R",
      "pygments_lexer": "r",
      "version": "4.0.5"
    },
    "papermill": {
      "default_parameters": {},
      "duration": 427.936706,
      "end_time": "2022-04-19T09:13:53.230849",
      "environment_variables": {},
      "exception": null,
      "input_path": "__notebook__.ipynb",
      "output_path": "__notebook__.ipynb",
      "parameters": {},
      "start_time": "2022-04-19T09:06:45.294143",
      "version": "2.3.4"
    },
    "colab": {
      "provenance": []
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}