{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "0",
   "metadata": {
    "id": "f02fa044",
    "papermill": {
     "duration": 0.012988,
     "end_time": "2022-04-19T09:06:48.772902",
     "exception": false,
     "start_time": "2022-04-19T09:06:48.759914",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Inference on Predictive and Causal Effects in High-Dimensional Nonlinear Models"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1",
   "metadata": {
    "id": "23154404",
    "papermill": {
     "duration": 0.009437,
     "end_time": "2022-04-19T09:06:48.791895",
     "exception": false,
     "start_time": "2022-04-19T09:06:48.782458",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Impact of 401(k) on  Financial Wealth\n",
    "\n",
    "We consider estimation of the effect of 401(k) participation\n",
    "on accumulated assets. 401(k) plans are pension accounts sponsored by employers. The key problem in determining the effect of participation in 401(k) plans on accumulated assets is saver heterogeneity coupled with the fact that the decision to enroll in a 401(k) is non-random. It is generally recognized that some people have a higher preference for saving than others. It also seems likely that those individuals with high unobserved preference for saving would be most likely to choose to participate in tax-advantaged retirement savings plans and would tend to have otherwise high amounts of accumulated assets. The presence of unobserved savings preferences with these properties then implies that conventional estimates that do not account for saver heterogeneity and endogeneity of participation will be biased upward, tending to overstate the savings effects of 401(k) participation.\n",
    "\n",
    "One can argue that eligibility for enrolling in a 401(k) plan in this data can be taken as exogenous after conditioning on a few observables of which the most important for their argument is income. The basic idea is that, at least around the time 401(k)â€™s initially became available, people were unlikely to be basing their employment decisions on whether an employer offered a 401(k) but would instead focus on income and other aspects of the job."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2",
   "metadata": {
    "id": "KmAkbDiVE7wm",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "install.packages(\"xtable\")\n",
    "install.packages(\"hdm\")\n",
    "install.packages(\"sandwich\")\n",
    "install.packages(\"ggplot2\")\n",
    "install.packages(\"randomForest\")\n",
    "install.packages(\"glmnet\")\n",
    "install.packages(\"rpart\")\n",
    "install.packages(\"data.table\")\n",
    "install.packages(\"gbm\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3",
   "metadata": {
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "library(xtable)\n",
    "library(hdm)\n",
    "library(sandwich)\n",
    "library(ggplot2)\n",
    "library(randomForest)\n",
    "library(data.table)\n",
    "library(glmnet)\n",
    "library(rpart)\n",
    "library(gbm)\n",
    "\n",
    "set.seed(123)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4",
   "metadata": {
    "id": "7e23cba0",
    "papermill": {
     "duration": 0.009588,
     "end_time": "2022-04-19T09:06:48.810853",
     "exception": false,
     "start_time": "2022-04-19T09:06:48.801265",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "### Data\n",
    "\n",
    "The raw dataset can be found [here](https://raw.githubusercontent.com/CausalAIBook/MetricsMLNotebooks/main/data/401k.csv).\n",
    "The data set can be loaded from the `hdm` package for R directly by typing:\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5",
   "metadata": {
    "id": "c442abdc",
    "papermill": {
     "duration": 0.46397,
     "end_time": "2022-04-19T09:06:49.283933",
     "exception": false,
     "start_time": "2022-04-19T09:06:48.819963",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "data(pension)\n",
    "data <- pension\n",
    "dim(data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6",
   "metadata": {
    "id": "e47fa9d3",
    "papermill": {
     "duration": 0.009462,
     "end_time": "2022-04-19T09:06:49.302928",
     "exception": false,
     "start_time": "2022-04-19T09:06:49.293466",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "See the \"Details\" section on the description of the data set, which can be accessed by\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7",
   "metadata": {
    "id": "00e04b82",
    "papermill": {
     "duration": 0.35227,
     "end_time": "2022-04-19T09:06:49.664810",
     "exception": false,
     "start_time": "2022-04-19T09:06:49.312540",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "help(pension)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8",
   "metadata": {
    "id": "24b41e4a",
    "papermill": {
     "duration": 0.009357,
     "end_time": "2022-04-19T09:06:49.683784",
     "exception": false,
     "start_time": "2022-04-19T09:06:49.674427",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "The data consist of 9,915 observations at the household level drawn from the 1991 Survey of Income and Program Participation (SIPP).  All the variables are referred to 1990. We use net financial assets (*net\\_tfa*) as the outcome variable, $Y$,  in our analysis. The net financial assets are computed as the sum of IRA balances, 401(k) balances, checking accounts, saving bonds, other interest-earning accounts, other interest-earning assets, stocks, and mutual funds less non mortgage debts."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9",
   "metadata": {
    "id": "ed9d4e82",
    "papermill": {
     "duration": 0.009242,
     "end_time": "2022-04-19T09:06:49.702401",
     "exception": false,
     "start_time": "2022-04-19T09:06:49.693159",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Among the $9915$ individuals, $3682$ are eligible to participate in the program. The variable *e401* indicates eligibility and *p401* indicates participation, respectively."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "10",
   "metadata": {
    "id": "63519184",
    "papermill": {
     "duration": 0.618528,
     "end_time": "2022-04-19T09:06:50.330218",
     "exception": false,
     "start_time": "2022-04-19T09:06:49.711690",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "hist_e401 <- ggplot(data, aes(x = e401, fill = factor(e401))) +\n",
    "  geom_bar()\n",
    "hist_e401"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "11",
   "metadata": {
    "id": "823d2628",
    "papermill": {
     "duration": 0.009686,
     "end_time": "2022-04-19T09:06:50.349766",
     "exception": false,
     "start_time": "2022-04-19T09:06:50.340080",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Eligibility is highly associated with financial wealth:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "12",
   "metadata": {
    "id": "5d8faf9c",
    "papermill": {
     "duration": 0.554613,
     "end_time": "2022-04-19T09:06:50.914133",
     "exception": false,
     "start_time": "2022-04-19T09:06:50.359520",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "dens_net_tfa <- ggplot(data, aes(x = net_tfa, color = factor(e401), fill = factor(e401))) +\n",
    "  geom_density() +\n",
    "  xlim(c(-20000, 150000)) +\n",
    "  facet_wrap(. ~ e401)\n",
    "\n",
    "dens_net_tfa"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "13",
   "metadata": {
    "id": "0f4f86a7",
    "papermill": {
     "duration": 0.010335,
     "end_time": "2022-04-19T09:06:50.935024",
     "exception": false,
     "start_time": "2022-04-19T09:06:50.924689",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "The unconditional APE of e401 is about $19559$:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "14",
   "metadata": {
    "id": "836c6af7",
    "papermill": {
     "duration": 0.038096,
     "end_time": "2022-04-19T09:06:50.983602",
     "exception": false,
     "start_time": "2022-04-19T09:06:50.945506",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "e1 <- data[data$e401 == 1, ]\n",
    "e0 <- data[data$e401 == 0, ]\n",
    "round(mean(e1$net_tfa) - mean(e0$net_tfa), 0)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "15",
   "metadata": {
    "id": "22b09926",
    "papermill": {
     "duration": 0.01047,
     "end_time": "2022-04-19T09:06:51.004618",
     "exception": false,
     "start_time": "2022-04-19T09:06:50.994148",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Among the $3682$ individuals that  are eligible, $2594$ decided to participate in the program. The unconditional APE of p401 is about $27372$:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "16",
   "metadata": {
    "id": "e78aaa58",
    "papermill": {
     "duration": 0.039305,
     "end_time": "2022-04-19T09:06:51.054616",
     "exception": false,
     "start_time": "2022-04-19T09:06:51.015311",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "p1 <- data[data$p401 == 1, ]\n",
    "p0 <- data[data$p401 == 0, ]\n",
    "round(mean(p1$net_tfa) - mean(p0$net_tfa), 0)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "17",
   "metadata": {
    "id": "e0af3c81",
    "papermill": {
     "duration": 0.010831,
     "end_time": "2022-04-19T09:06:51.076114",
     "exception": false,
     "start_time": "2022-04-19T09:06:51.065283",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "As discussed, these estimates are biased since they do not account for saver heterogeneity and endogeneity of participation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "18",
   "metadata": {
    "id": "A03YWrvUW0Sm",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# instrument variable\n",
    "Z <- data[, \"e401\"]\n",
    "# treatment variable\n",
    "D <- data[, \"p401\"]\n",
    "# outcome variable\n",
    "y <- data[, \"net_tfa\"]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "19",
   "metadata": {
    "id": "RVUbOMRRWwBm"
   },
   "source": [
    "### We construct the engineered features for controls"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "20",
   "metadata": {
    "id": "7vt1hbdBG8cb",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# Constructing the controls\n",
    "x_formula <- paste(\"~ poly(age, 6, raw=TRUE) + poly(inc, 8, raw=TRUE) + poly(educ, 4, raw=TRUE) + \",\n",
    "                   \"poly(fsize, 2, raw=TRUE) + male + marr + twoearn + db + pira + hown\")\n",
    "X <- as.data.table(model.frame(x_formula, pension))\n",
    "head(X)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "21",
   "metadata": {
    "id": "yzNigd7YYVuA"
   },
   "source": [
    "# Instrumental Variables: Effect of 401k Participation on Financial Assets"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "22",
   "metadata": {
    "id": "FI2u5KU7YWIF"
   },
   "source": [
    "## Double ML IV under Partial Linearity"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "23",
   "metadata": {
    "id": "uhDK6Em_YWSm"
   },
   "source": [
    "Now, we consider estimation of average treatment effects of participation in 401k, i.e. `p401`, with the binary instrument being eligibility in 401k, i.e. `e401`. As before, $Y$ denotes the outcome `net_tfa`, and $X$ is the vector of covariates. We consider a partially linear structural equation model:\n",
    "\\begin{align}\n",
    "Y :=~& g_Y(\\epsilon_Y) D + f_Y(A, X, \\epsilon_Y),  \\\\\n",
    "D :=~& f_D(Z, X, A, \\epsilon_D), \\\\\n",
    "Z :=~& f_Z(X, \\epsilon_Z),\\\\\n",
    "A :=~& f_A(X, \\epsilon_A), \\\\\n",
    "X :=~&  \\epsilon_X,\n",
    "\\end{align}\n",
    "where $A$ is a vector of un-observed confounders.\n",
    "\n",
    "Under this structural equation model, the average treatment effect:\n",
    "\\begin{align}\n",
    "\\alpha = E[Y(1) - Y(0)]\n",
    "\\end{align}\n",
    "can be identified by the moment restriction:\n",
    "\\begin{align}\n",
    "E[(\\tilde{Y} - \\alpha \\tilde{D}) \\tilde{Z}] = 0\n",
    "\\end{align}\n",
    "where for any variable $V$, we denote with $\\tilde{V} = V - E[V|X]$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "24",
   "metadata": {
    "id": "bdUGB53AYf3S",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "set.seed(1)\n",
    "# family gaussian means that we'll be using square loss\n",
    "yfit_lasso_cv <- cv.glmnet(as.matrix(X), y, family = \"gaussian\", alpha = 1)\n",
    "# family gaussian means that we'll be using square loss\n",
    "dfit_lasso_cv <- cv.glmnet(as.matrix(X), D, family = \"gaussian\", alpha = 1)\n",
    "# family gaussian means that we'll be using square loss\n",
    "zfit_lasso_cv <- cv.glmnet(as.matrix(X), Z, family = \"gaussian\", alpha = 1)\n",
    "\n",
    "\n",
    "yhat_lasso_cv <- predict(yfit_lasso_cv, newx = as.matrix(X)) # predictions\n",
    "dhat_lasso_cv <- predict(dfit_lasso_cv, newx = as.matrix(X)) # predictions\n",
    "zhat_lasso_cv <- predict(zfit_lasso_cv, newx = as.matrix(X)) # predictions\n",
    "\n",
    "resy <- y - yhat_lasso_cv\n",
    "resD <- D - dhat_lasso_cv\n",
    "resZ <- Z - zhat_lasso_cv\n",
    "\n",
    "# Estimate\n",
    "mean(resy * resZ) / mean(resZ * resD)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "25",
   "metadata": {
    "id": "Fw1ZxeBKZcRm"
   },
   "source": [
    "Recall if we want to do inference, we need to either use the theoretically driven penalty paramter for Lasso or perform cross-fitting."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "26",
   "metadata": {
    "id": "jnBOtXXuZnkz"
   },
   "source": [
    "### DML with Non-Linear ML Models and Cross-fitting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "27",
   "metadata": {
    "id": "K_vQlMYmz91I",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# DML for PLIVM with D and Z as classifiers or regressors\n",
    "dml2_for_plivm <- function(x, d, z, y, dreg, yreg, zreg, nfold = 5, method = \"regression\") {\n",
    "  nobs <- nrow(x)\n",
    "  foldid <- rep.int(1:nfold, times = ceiling(nobs / nfold))[sample.int(nobs)]\n",
    "  I <- split(1:nobs, foldid)\n",
    "  # create residualized objects to fill\n",
    "  ytil <- dtil <- ztil <- rep(NA, nobs)\n",
    "  # obtain cross-fitted residuals\n",
    "  cat(\"fold: \")\n",
    "  for (b in seq_along(I)) {\n",
    "    if (method == \"randomforest\") {\n",
    "      # take a fold out\n",
    "      dfit <- dreg(x[-I[[b]], ], d[-I[[b]]])\n",
    "      zfit <- zreg(x[-I[[b]], ], z[-I[[b]]])\n",
    "      yfit <- yreg(x[-I[[b]], ], y[-I[[b]]])\n",
    "      # predict the fold out\n",
    "      dhat <- predict(dfit, x[I[[b]], ], type = \"prob\")[, 2] # type = \"prob\" is like predict_proba in scikitlearn\n",
    "      zhat <- predict(zfit, x[I[[b]], ], type = \"prob\")[, 2]\n",
    "      # default type = \"response\" for regression for RF, type = \"vector\" for regression for Decision Trees\n",
    "      yhat <- predict(yfit, x[I[[b]], ])\n",
    "      # record residual\n",
    "      # as.numeric will turn d = as.factor(d) from 0,1 to 1,2 so subtract 1!\n",
    "      dtil[I[[b]]] <- (as.numeric(d[I[[b]]]) - 1 - dhat)\n",
    "      ztil[I[[b]]] <- (as.numeric(z[I[[b]]]) - 1 - zhat)\n",
    "      ytil[I[[b]]] <- (y[I[[b]]] - yhat)\n",
    "    } else if (method == \"regression\") { # works for both boosted trees and glmnet\n",
    "      # take a fold out\n",
    "      dfit <- dreg(x[-I[[b]], ], d[-I[[b]]])\n",
    "      zfit <- zreg(x[-I[[b]], ], z[-I[[b]]])\n",
    "      yfit <- yreg(x[-I[[b]], ], y[-I[[b]]])\n",
    "      # predict the fold out\n",
    "      dhat <- predict(dfit, x[I[[b]], ], type = \"response\")\n",
    "      zhat <- predict(zfit, x[I[[b]], ], type = \"response\")\n",
    "      yhat <- predict(yfit, x[I[[b]], ], type = \"response\")\n",
    "      # record residual\n",
    "      dtil[I[[b]]] <- (d[I[[b]]] - dhat)\n",
    "      ztil[I[[b]]] <- (z[I[[b]]] - zhat)\n",
    "      ytil[I[[b]]] <- (y[I[[b]]] - yhat)\n",
    "    } else if (method == \"decisiontrees\") {\n",
    "      # take a fold out\n",
    "      dfit <- dreg(x[-I[[b]], ], as.factor(d)[-I[[b]]])\n",
    "      zfit <- zreg(x[-I[[b]], ], as.factor(z)[-I[[b]]])\n",
    "      yfit <- yreg(x[-I[[b]], ], y[-I[[b]]])\n",
    "      # predict the fold out\n",
    "      dhat <- predict(dfit, x[I[[b]], ])[, 2]\n",
    "      zhat <- predict(zfit, x[I[[b]], ])[, 2]\n",
    "      yhat <- predict(yfit, x[I[[b]], ])\n",
    "      # record residual\n",
    "      dtil[I[[b]]] <- (d[I[[b]]] - dhat)\n",
    "      ztil[I[[b]]] <- (z[I[[b]]] - zhat)\n",
    "      ytil[I[[b]]] <- (y[I[[b]]] - yhat)\n",
    "    }\n",
    "\n",
    "    cat(b, \" \")\n",
    "  }\n",
    "  ivfit <- tsls(y = ytil, d = dtil, x = NULL, z = ztil, intercept = FALSE)\n",
    "  coef_est <- ivfit$coef # extract coefficient\n",
    "  se <- ivfit$se # record standard error\n",
    "  cat(sprintf(\"\\ncoef (se) = %g (%g)\\n\", coef_est, se))\n",
    "\n",
    "  return(list(coef_est = coef_est, se = se, dtil = dtil, ytil = ytil, ztil = ztil))\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "28",
   "metadata": {
    "id": "puSCLNvofQxA",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "summary_for_plivm <- function(point, stderr, resy, resD, resZ, name) {\n",
    "  data <- data.frame(\n",
    "    estimate = point, # point estimate\n",
    "    stderr = stderr, # standard error\n",
    "    lower = point - 1.96 * stderr, # lower end of 95% confidence interval\n",
    "    upper = point + 1.96 * stderr, # upper end of 95% confidence interval\n",
    "    `rmse y` = sqrt(mean(resy^2)), # RMSE of model that predicts outcome y\n",
    "    `rmse D` = sqrt(mean(resD^2)), # RMSE of model that predicts treatment D\n",
    "    `rmse Z` = sqrt(mean(resZ^2)), # RMSE of model that predicts treatment D\n",
    "    `accuracy D` = mean(abs(resD) < 0.5), # binary classification accuracy of model for D\n",
    "    `accuracy Z` = mean(abs(resZ) < 0.5) # binary classification accuracy of model for Z\n",
    "  )\n",
    "  rownames(data) <- name\n",
    "  return(data)\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "29",
   "metadata": {
    "id": "1Z5vrvrlbuPj"
   },
   "source": [
    "#### Double Lasso with Cross-Fitting"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "30",
   "metadata": {
    "id": "vBJm7BkUYgsG",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# DML with LassoCV\n",
    "set.seed(123)\n",
    "cat(sprintf(\"\\nDML with Lasso CV \\n\"))\n",
    "\n",
    "dreg_lasso_cv <- function(x, d) {\n",
    "  cv.glmnet(x, d, family = \"gaussian\", alpha = 1, nfolds = 5)\n",
    "}\n",
    "yreg_lasso_cv <- function(x, y) {\n",
    "  cv.glmnet(x, y, family = \"gaussian\", alpha = 1, nfolds = 5)\n",
    "}\n",
    "zreg_lasso_cv <- function(x, z) {\n",
    "  cv.glmnet(x, z, family = \"gaussian\", alpha = 1, nfolds = 5)\n",
    "}\n",
    "\n",
    "dml2_results <- dml2_for_plivm(as.matrix(X), D, Z, y, dreg_lasso_cv, yreg_lasso_cv, zreg_lasso_cv,\n",
    "                               nfold = 5, method = \"regression\")\n",
    "sum_lasso_cv <- summary_for_plivm(dml2_results$coef_est, dml2_results$se, dml2_results$ytil, dml2_results$dtil,\n",
    "                                  dml2_results$ztil, name = \"LassoCV\")\n",
    "tableplr <- data.frame()\n",
    "tableplr <- rbind(sum_lasso_cv)\n",
    "tableplr\n",
    "\n",
    "ytil_lasso <- dml2_results$ytil\n",
    "dtil_lasso <- dml2_results$dtil\n",
    "ztil_lasso <- dml2_results$ztil"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "31",
   "metadata": {
    "id": "pyrem2YniNls"
   },
   "source": [
    "#### Using a $\\ell_2$ Penalized Logistic Regression for D and Z"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "32",
   "metadata": {
    "id": "FM6WvQXKYgxL",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# DML with Lasso/Ridge\n",
    "set.seed(123)\n",
    "cat(sprintf(\"\\nDML with Lasso/Logistic \\n\"))\n",
    "\n",
    "dreg_ridge_cv <- function(x, d) {\n",
    "  cv.glmnet(x, d, family = \"binomial\", alpha = 0, nfolds = 5)\n",
    "}\n",
    "yreg_ridge_cv <- function(x, y) {\n",
    "  cv.glmnet(x, y, family = \"gaussian\", alpha = 1, nfolds = 5)\n",
    "}\n",
    "zreg_ridge_cv <- function(x, z) {\n",
    "  cv.glmnet(x, z, family = \"binomial\", alpha = 0, nfolds = 5)\n",
    "}\n",
    "\n",
    "dml2_results <- dml2_for_plivm(as.matrix(X), D, Z, y, dreg_ridge_cv, yreg_ridge_cv, zreg_ridge_cv,\n",
    "                               nfold = 5, method = \"regression\")\n",
    "sum_lasso_ridge_cv <- summary_for_plivm(dml2_results$coef_est, dml2_results$se, dml2_results$ytil, dml2_results$dtil,\n",
    "                                        dml2_results$ztil, name = \"LassoCV/LogisticCV\")\n",
    "tableplr <- rbind(tableplr, sum_lasso_ridge_cv)\n",
    "tableplr\n",
    "\n",
    "ytil_ridge <- dml2_results$ytil\n",
    "dtil_ridge <- dml2_results$dtil\n",
    "ztil_ridge <- dml2_results$ztil"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "33",
   "metadata": {
    "id": "yfTdX3__jcwI"
   },
   "source": [
    "### Random Forests"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "34",
   "metadata": {
    "id": "mMvJT6NZHW1_",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# DML with Random Forest\n",
    "set.seed(123)\n",
    "cat(sprintf(\"\\nDML with Random Forest \\n\"))\n",
    "\n",
    "dreg_rf <- function(x, d) {\n",
    "  randomForest(x, d, ntree = 1000, nodesize = 10)\n",
    "} # ML method=Forest\n",
    "yreg_rf <- function(x, y) {\n",
    "  randomForest(x, y, ntree = 1000, nodesize = 10)\n",
    "} # ML method=Forest\n",
    "zreg_rf <- function(x, z) {\n",
    "  randomForest(x, z, ntree = 1000, nodesize = 10)\n",
    "} # ML method=Forest\n",
    "\n",
    "dml2_results <- dml2_for_plivm(as.matrix(X), as.factor(D), as.factor(Z), y, dreg_rf, yreg_rf, zreg_rf,\n",
    "                               nfold = 5, method = \"randomforest\")\n",
    "sum_rf <- summary_for_plivm(dml2_results$coef_est, dml2_results$se, dml2_results$ytil, dml2_results$dtil,\n",
    "                            dml2_results$ztil, name = \"RF\")\n",
    "tableplr <- rbind(tableplr, sum_rf)\n",
    "tableplr\n",
    "\n",
    "ytil_rf <- dml2_results$ytil\n",
    "dtil_rf <- dml2_results$dtil\n",
    "ztil_rf <- dml2_results$ztil"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "35",
   "metadata": {
    "id": "4I1oVQutjeqE"
   },
   "source": [
    "### Decision Trees"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "36",
   "metadata": {
    "id": "ayrnTPeBHW88",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# DML with Decision Trees\n",
    "set.seed(123)\n",
    "cat(sprintf(\"\\nDML with Decision Trees \\n\"))\n",
    "\n",
    "# decision tree takes in X as dataframe, not matrix/array\n",
    "dreg_tr <- function(x, d) {\n",
    "  rpart(as.formula(\"D~.\"), cbind(data.frame(D = d), x), method = \"class\", minbucket = 10, cp = 0.001)\n",
    "}\n",
    "yreg_tr <- function(x, y) {\n",
    "  rpart(as.formula(\"y~.\"), cbind(data.frame(y = y), x), minbucket = 10, cp = 0.001)\n",
    "}\n",
    "zreg_tr <- function(x, z) {\n",
    "  rpart(as.formula(\"Z~.\"), cbind(data.frame(Z = z), x), method = \"class\", minbucket = 10, cp = 0.001)\n",
    "}\n",
    "\n",
    "dml2_results <- dml2_for_plivm(X, D, Z, y, dreg_tr, yreg_tr, zreg_tr,\n",
    "                               nfold = 5, method = \"decisiontrees\")\n",
    "sum_tr <- summary_for_plivm(dml2_results$coef_est, dml2_results$se, dml2_results$ytil, dml2_results$dtil,\n",
    "                            dml2_results$ztil, name = \"Decision Trees\")\n",
    "tableplr <- rbind(tableplr, sum_tr)\n",
    "tableplr\n",
    "\n",
    "ytil_tr <- dml2_results$ytil\n",
    "dtil_tr <- dml2_results$dtil\n",
    "ztil_tr <- dml2_results$ztil"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "37",
   "metadata": {
    "id": "h7Jo_WXUjgjb"
   },
   "source": [
    "### Boosted Trees"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "38",
   "metadata": {
    "id": "nzlszy9zjiSy",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# DML with Boosted Trees\n",
    "set.seed(123)\n",
    "cat(sprintf(\"\\nDML with Boosted Trees \\n\"))\n",
    "\n",
    "# NB: early stopping cannot easily be implemented with gbm\n",
    "## set n.trees = best, where best <- gbm.perf(dreg_boost, plot.it = FALSE)\n",
    "dreg_boost <- function(x, d) {\n",
    "  gbm(as.formula(\"D~.\"), cbind(data.frame(D = d), x), distribution = \"bernoulli\",\n",
    "      interaction.depth = 2, n.trees = 100, shrinkage = .1)\n",
    "}\n",
    "yreg_boost <- function(x, y) {\n",
    "  gbm(as.formula(\"y~.\"), cbind(data.frame(y = y), x), distribution = \"gaussian\",\n",
    "      interaction.depth = 2, n.trees = 100, shrinkage = .1)\n",
    "}\n",
    "zreg_boost <- function(x, z) {\n",
    "  gbm(as.formula(\"Z~.\"), cbind(data.frame(Z = z), x), distribution = \"bernoulli\",\n",
    "      interaction.depth = 2, n.trees = 100, shrinkage = .1)\n",
    "}\n",
    "\n",
    "# passing these through regression as type=\"response\", and D and Z should not be factors!\n",
    "dml2_results <- dml2_for_plivm(X, D, Z, y, dreg_boost, yreg_boost, zreg_boost,\n",
    "                               nfold = 5, method = \"regression\")\n",
    "sum_boost <- summary_for_plivm(dml2_results$coef_est, dml2_results$se, dml2_results$ytil, dml2_results$dtil,\n",
    "                               dml2_results$ztil, name = \"Boosted Trees\")\n",
    "tableplr <- rbind(tableplr, sum_boost)\n",
    "tableplr\n",
    "\n",
    "ytil_boost <- dml2_results$ytil\n",
    "dtil_boost <- dml2_results$dtil\n",
    "ztil_boost <- dml2_results$ztil"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "39",
   "metadata": {
    "id": "oQpoYedAc4Ic"
   },
   "source": [
    "## Ensembles"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "40",
   "metadata": {
    "id": "_LLsorarc8Mh"
   },
   "source": [
    "Boosted trees give the best RMSE for Y, D, and Z, so the ensemble based on choosing the best performing prediction rule is identical to boosting in this case."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "41",
   "metadata": {
    "id": "kAePILCadEVh",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# Best fit is boosted trees for D, Z, Y\n",
    "\n",
    "sum_best <- summary_for_plivm(dml2_results$coef_est, dml2_results$se, dml2_results$ytil, dml2_results$dtil,\n",
    "                              dml2_results$ztil, name = \"Best\")\n",
    "tableplr <- rbind(tableplr, sum_best)\n",
    "tableplr"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "42",
   "metadata": {
    "id": "KaaDX4kkdIMx"
   },
   "source": [
    "We'll form a model average with unconstrained least squares weights."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "43",
   "metadata": {
    "id": "mCsyY3iJdHm_",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# Least squares model average\n",
    "\n",
    "dhat_lasso <- D - dtil_lasso\n",
    "dhat_ridge <- D - dtil_ridge\n",
    "dhat_rf <- D - dtil_rf\n",
    "dhat_tr <- D - dtil_tr\n",
    "dhat_boost <- D - dtil_boost\n",
    "\n",
    "yhat_lasso <- y - ytil_lasso\n",
    "yhat_ridge <- y - ytil_ridge\n",
    "yhat_rf <- y - ytil_rf\n",
    "yhat_tr <- y - ytil_tr\n",
    "yhat_boost <- y - ytil_boost\n",
    "\n",
    "zhat_lasso <- Z - ztil_lasso\n",
    "zhat_ridge <- Z - ztil_ridge\n",
    "zhat_rf <- Z - ztil_rf\n",
    "zhat_tr <- Z - ztil_tr\n",
    "zhat_boost <- Z - ztil_boost\n",
    "\n",
    "ma_dtil <- lm(D ~ dhat_lasso + dhat_ridge + dhat_rf + dhat_tr + dhat_boost)$residuals\n",
    "ma_ytil <- lm(y ~ yhat_lasso + yhat_ridge + yhat_rf + yhat_tr + yhat_boost)$residuals\n",
    "ma_ztil <- lm(Z ~ zhat_lasso + zhat_ridge + zhat_rf + zhat_tr + zhat_boost)$residuals\n",
    "\n",
    "ivfit <- tsls(y = ma_ytil, d = ma_dtil, x = NULL, z = ma_ztil, intercept = FALSE)\n",
    "coef_est <- ivfit$coef # extract coefficient\n",
    "se <- ivfit$se # record standard error\n",
    "\n",
    "sum_ma <- summary_for_plivm(coef_est, se, ma_ytil, ma_dtil, ma_ztil, name = \"Model Average\")\n",
    "tableplr <- rbind(tableplr, sum_ma)\n",
    "tableplr"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "44",
   "metadata": {
    "id": "8OUusM2BpZH4"
   },
   "source": [
    "## Inference Robust to Weak Identification\n",
    "\n",
    "Now we turn toward robustness when the instrument is weak.\n",
    "\n",
    "Ideally, we would do (semi) cross-fitting with AutoML in order to find good first-stage models and re-run DML with these models. Unfortunately this is not easy to do in R. In the case of semi cross-fitting, we can use R's H20 AutoML trained on the entire training set $y\\sim X$, $D \\sim X$, $Z\\sim X$ to determine the best model (eg ensemble), but H20 does not allow you to extract the best model so we can re-use that in DML.\n",
    "\n",
    "Thus, in the below analysis of robust inference, we choose Boosted Trees as they perform well."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "45",
   "metadata": {
    "id": "UeNF5j1ApYYy",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "robust_inference <- function(point, stderr, resD, resy, resZ, grid, alpha = 0.05) {\n",
    "  # Inference in the partially linear IV model that is robust to weak identification.\n",
    "  # grid: grid of theta values to search over when trying to identify the confidence region\n",
    "  # alpha: confidence level\n",
    "\n",
    "  n <- dim(X)[1]\n",
    "  thr <- qchisq(1 - alpha, df = 1)\n",
    "  accept <- c()\n",
    "\n",
    "  for (theta in grid) {\n",
    "    moment <- (resy - theta * resD) * resZ\n",
    "    test <- n * mean(moment)^2 / var(moment)\n",
    "    if (test <= thr) {\n",
    "      accept <- c(accept, theta)\n",
    "    }\n",
    "  }\n",
    "\n",
    "  return(accept)\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "46",
   "metadata": {
    "id": "X21PuuUnsa25",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "grid <- seq(0, 20000, length.out = 10000)\n",
    "region <- robust_inference(dml2_results$coef_est, dml2_results$stderr, dml2_results$dtil, dml2_results$ytil,\n",
    "                           dml2_results$ztil, grid = grid)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "47",
   "metadata": {
    "id": "x-ZSzMkVqI45",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "grid <- seq(0, 20000, length.out = 10000)\n",
    "region <- robust_inference(dml2_results$coef_est, dml2_results$stderr, dml2_results$dtil, dml2_results$ytil,\n",
    "                           dml2_results$ztil, grid = grid)\n",
    "# Calculate min and max\n",
    "min_region <- min(region)\n",
    "max_region <- max(region)\n",
    "\n",
    "print(min_region)\n",
    "print(max_region)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "48",
   "metadata": {
    "id": "nKQGPfXWIKmh"
   },
   "source": [
    "# Interactive IV Model and LATE"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "49",
   "metadata": {
    "id": "bCayhAlaINjL"
   },
   "source": [
    "Now, we consider estimation of local average treatment effects (LATE) of participation `p401`, with the binary instrument `e401`. As before, $Y$ denotes the outcome `net_tfa`, and $X$ is the vector of covariates.  Here the structural equation model is:\n",
    "\\begin{align}\n",
    "Y :=~&  f_Y (D, X, A, \\epsilon_Y) \\\\\n",
    "D :=~& f_D(Z, X, A, \\epsilon_D) \\in \\{0,1\\},  \\\\\n",
    "Z :=~& f_Z(X,\\epsilon_Z) \\in \\{0,1\\},  \\\\\n",
    "X :=~&  \\epsilon_X, \\quad A = \\epsilon_A,\n",
    "\\end{align}\n",
    "where $\\epsilon$'s are all exogenous and independent,\n",
    "and\n",
    "$$\n",
    "z \\mapsto f_D(z , A, X, \\epsilon_D) \\text{ is weakly increasing (weakly monotone)}.\n",
    "$$\n",
    "and $A$ is a vector of unobserved confounders. Note that in our setting monotonicity is satisfied, since participation is only feasible when it is eligible. Thus we have that $D=0$ whenever $Z=0$. Thus it can only be that $f_D(1, A, X, \\epsilon_D) \\geq 0 = f_D(0, A, X, \\epsilon_D)$.\n",
    "\n",
    "In this case, we can estimate the local average treatment effect (LATE):\n",
    "$$\n",
    "\\alpha = E[Y(1) - Y(0) | D(1) > D(0)]\n",
    "$$\n",
    "This can be identified using the Neyman orthogonal moment equation:\n",
    "\\begin{align}\n",
    "E\\left[g(1, X) - g(0, X) + H(Z) (Y - g(Z, X)) - \\alpha \\cdot  (m(1, X) - m(0, X) + H(Z) (D - m(Z, X))\\right] = 0\n",
    "\\end{align}\n",
    "where\n",
    "\\begin{align}\n",
    "g(Z,X) =~& E[Y|Z,X],\\\\\n",
    "m(Z,X) =~& E[D|Z,X],\\\\\n",
    "H(Z) =~& \\frac{Z}{Pr(Z=1|X)} - \\frac{1 - Z}{1 - Pr(Z=1|X)}\n",
    "\\end{align}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "50",
   "metadata": {
    "id": "rQYifUnFIt5z",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "get_dhat0 <- function(XZ0, DZ0, Xb, dreg0, type = NULL, DZ0factor = NULL) {\n",
    "  # train a treatment model on training data that received Z=0 and predict treatment on all data in test set\n",
    "  if (mean(DZ0) > 0) { # it could be that D=0, whenever Z=0 deterministically\n",
    "    dreg0_ <- dreg0\n",
    "    if (is.null(DZ0factor)) {\n",
    "      dfit0 <- dreg0_((XZ0), DZ0)\n",
    "    } else {\n",
    "      dfit0 <- dreg0_((XZ0), DZ0factor)\n",
    "    }\n",
    "    if (is.null(type)) {\n",
    "      return(predict(dfit0, (Xb))[, 2])\n",
    "    } else if (type == \"prob\") {\n",
    "      return(predict(dfit0, (Xb), type = \"prob\")[, 2])\n",
    "    } else if (type == \"reponse\") {\n",
    "      return(predict(dfit0, (Xb), type = \"response\"))\n",
    "    } else {\n",
    "      stop(\"Invalid argument `type`.\")\n",
    "    }\n",
    "  } else {\n",
    "    return(0)\n",
    "  }\n",
    "}\n",
    "\n",
    "get_dhat1 <- function(XZ1, DZ1, Xb, dreg1, type = NULL, DZ1factor = NULL) {\n",
    "  # train a treamtent model on training data that received Z=1 and predict treatment on all data in test set\n",
    "  if (mean(DZ1) < 1) { # it could be that D=1, whenever Z=1 deterministically\n",
    "    dreg1_ <- dreg1\n",
    "    if (is.null(DZ1factor)) {\n",
    "      dfit1 <- dreg1_((XZ1), DZ1)\n",
    "    } else {\n",
    "      dfit1 <- dreg1_((XZ1), DZ1factor)\n",
    "    }\n",
    "    if (is.null(type)) {\n",
    "      return(predict(dfit1, (Xb))[, 2])\n",
    "    } else if (type == \"prob\") {\n",
    "      return(predict(dfit1, (Xb), type = \"prob\")[, 2])\n",
    "    } else if (type == \"response\") {\n",
    "      return(predict(dfit1, (Xb), type = \"response\"))\n",
    "    } else {\n",
    "      stop(\"Invalid argument `type`.\")\n",
    "    }\n",
    "  } else {\n",
    "    return(1)\n",
    "  }\n",
    "}\n",
    "\n",
    "# DML for IIVM with D and Z as classifiers or regressors\n",
    "dml2_for_iivm <- function(x, d, z, y, dreg0, dreg1, yreg0, yreg1, zreg,\n",
    "                          trimming = 0.01, nfold = 5, method = \"classification\", dt = 0, bt = 0) {\n",
    "  # this implements DML2 algorithm, where there moments are estimated via DML, before constructing\n",
    "  # the pooled estimate of theta randomly split data into folds\n",
    "\n",
    "  ## NB This method has many if statements to accommodate the various estimators we will use.\n",
    "  ## Unlike Python's sklearn, all methods have idfferent default arguments in their predict functions.\n",
    "  ## See official R documentation for details.\n",
    "\n",
    "  yhat0 <- rep(0, length(y))\n",
    "  yhat1 <- rep(0, length(y))\n",
    "  dhat0 <- rep(0, length(d))\n",
    "  dhat1 <- rep(0, length(d))\n",
    "  zhat <- rep(0, length(Z))\n",
    "\n",
    "  nobs <- nrow(X)\n",
    "  foldid <- rep.int(1:nfold, times = ceiling(nobs / nfold))[sample.int(nobs)]\n",
    "  I <- split(1:nobs, foldid)\n",
    "  # create residualized objects to fill\n",
    "  ytil <- dtil <- ztil <- rep(NA, nobs)\n",
    "\n",
    "  # obtain cross-fitted residuals\n",
    "  cat(\"fold: \")\n",
    "  for (b in seq_along(I)) {\n",
    "    # define helpful variables\n",
    "    Xb <- X[I[[b]], ]\n",
    "    Xnotb <- X[-I[[b]], ]\n",
    "    Znotb <- Z[-I[[b]]]\n",
    "\n",
    "    # training dfs subsetted on the -I[[b]] fold\n",
    "    XZ0 <- X[-I[[b]], ][Z[-I[[b]]] == 0]\n",
    "    yZ0 <- y[-I[[b]]][Z[-I[[b]]] == 0]\n",
    "    XZ1 <- X[-I[[b]], ][Z[-I[[b]]] == 1]\n",
    "    yZ1 <- y[-I[[b]]][Z[-I[[b]]] == 1]\n",
    "    DZ0 <- d[-I[[b]]][Z[-I[[b]]] == 0]\n",
    "    DZ1 <- d[-I[[b]]][Z[-I[[b]]] == 1]\n",
    "\n",
    "\n",
    "    if (method == \"regression\") {\n",
    "      XZ0 <- as.matrix(XZ0)\n",
    "      XZ1 <- as.matrix(XZ1)\n",
    "      Xb <- as.matrix(Xb)\n",
    "      Xnotb <- as.matrix(Xnotb)\n",
    "\n",
    "      # Train an outcome model on training data that received Z=0 and predict outcome on all data in the test set\n",
    "      yfit0 <- yreg0((XZ0), yZ0)\n",
    "      yhat0[I[[b]]] <- predict(yfit0, (Xb)) # default type = \"response\"\n",
    "\n",
    "      # train an outcome model on training data that received Z=1 and predict outcome on all data in test set\n",
    "      yfit1 <- yreg1((XZ1), yZ1)\n",
    "      yhat1[I[[b]]] <- predict(yfit1, (Xb))\n",
    "\n",
    "      # train a treatment model on training data that received Z=0 and predict treatment on all data in test set\n",
    "      # default type = \"response\", but for family binomial it's logg odds\n",
    "      dhat0[I[[b]]] <- get_dhat0(XZ0, DZ0, Xb, dreg0, type = \"response\")\n",
    "      dhat1[I[[b]]] <- get_dhat1(XZ1, DZ1, Xb, dreg1, type = \"response\")\n",
    "\n",
    "    } else if (method == \"randomforest\") {\n",
    "      DZ0factor <- as.factor(D)[-I[[b]]][Z[-I[[b]]] == 0]\n",
    "      DZ1factor <- as.factor(D)[-I[[b]]][Z[-I[[b]]] == 1]\n",
    "      Znotb <- as.factor(Znotb)\n",
    "\n",
    "      yfit0 <- yreg0((XZ0), yZ0)\n",
    "      yhat0[I[[b]]] <- predict(yfit0, (Xb), type = \"response\")\n",
    "      yfit1 <- yreg1((XZ1), yZ1)\n",
    "      yhat1[I[[b]]] <- predict(yfit1, (Xb), type = \"response\")\n",
    "\n",
    "      dhat0[I[[b]]] <- get_dhat0(XZ0, DZ0, Xb, dreg0, type = \"prob\", DZ0factor = DZ0factor)\n",
    "      dhat1[I[[b]]] <- get_dhat1(XZ1, DZ1, Xb, dreg1, type = \"prob\", DZ1factor = DZ1factor)\n",
    "\n",
    "    } else if (method == \"decisiontrees\") {\n",
    "      XZ0 <- as.data.frame(XZ0)\n",
    "      XZ1 <- as.data.frame(XZ1)\n",
    "      Xb <- as.data.frame(Xb)\n",
    "      Xnotb <- as.data.frame(Xnotb)\n",
    "\n",
    "      yfit0 <- yreg0((XZ0), yZ0)\n",
    "      # default type = \"response\" for decision trees for continuous response\n",
    "      yhat0[I[[b]]] <- predict(yfit0, (Xb))\n",
    "\n",
    "      yfit1 <- yreg1((XZ1), yZ1)\n",
    "      yhat1[I[[b]]] <- predict(yfit1, (Xb))\n",
    "\n",
    "      dhat0[I[[b]]] <- get_dhat0(XZ0, DZ0, Xb, dreg0, DZ0factor = as.factor(DZ0))\n",
    "      dhat1[I[[b]]] <- get_dhat1(XZ1, DZ1, Xb, dreg1, DZ1factor = as.factor(DZ1))\n",
    "\n",
    "    } else if (method == \"boostedtrees\") {\n",
    "      XZ0 <- as.data.frame(XZ0)\n",
    "      XZ1 <- as.data.frame(XZ1)\n",
    "      Xb <- as.data.frame(Xb)\n",
    "      Xnotb <- as.data.frame(Xnotb)\n",
    "\n",
    "      yfit0 <- yreg0((XZ0), yZ0)\n",
    "      yhat0[I[[b]]] <- predict(yfit0, (Xb)) # default type = \"response\" for boosted trees\n",
    "      yfit1 <- yreg1((XZ1), yZ1)\n",
    "      yhat1[I[[b]]] <- predict(yfit1, (Xb))\n",
    "\n",
    "      dhat0[I[[b]]] <- get_dhat0(XZ0, DZ0, Xb, dreg0, type = \"response\")\n",
    "      dhat1[I[[b]]] <- get_dhat1(XZ1, DZ1, Xb, dreg1, type = \"response\")\n",
    "\n",
    "    }\n",
    "\n",
    "    # propensity scores:\n",
    "    if (method == \"regression\") {\n",
    "      zfit_b <- zreg((Xnotb), Znotb)\n",
    "      zhat_b <- predict(zfit_b, (Xb), type = \"response\")\n",
    "    } else if (method == \"randomforest\") {\n",
    "      zfit_b <- zreg((Xnotb), Znotb)\n",
    "      zhat_b <- predict(zfit_b, (Xb), type = \"prob\")[, 2]\n",
    "    } else if (method == \"decisiontrees\") {\n",
    "      zfit_b <- zreg((Xnotb), as.factor(Znotb))\n",
    "      zhat_b <- predict(zfit_b, (Xb)) # default is prob, so get second column\n",
    "      zhat_b <- zhat_b[, 2]\n",
    "    } else if (method == \"boostedtrees\") {\n",
    "      zfit_b <- zreg((Xnotb), Znotb)\n",
    "      zhat_b <- predict(zfit_b, (Xb), type = \"response\")\n",
    "    }\n",
    "    zhat_b <- pmax(pmin(zhat_b, 1 - trimming), trimming) # trimming so scores are between [trimming, (1-trimming)]\n",
    "    zhat[I[[b]]] <- zhat_b\n",
    "\n",
    "    cat(b, \" \")\n",
    "  }\n",
    "\n",
    "\n",
    "  # Prediction of treatment and outcome for observed instrument\n",
    "  yhat <- yhat0 * (1 - Z) + yhat1 * Z\n",
    "  dhat <- dhat0 * (1 - Z) + dhat1 * Z\n",
    "\n",
    "  # residuals\n",
    "  ytil <- y - yhat\n",
    "  dtil <- D - dhat\n",
    "  ztil <- Z - zhat\n",
    "\n",
    "  # doubly robust quantity for every sample\n",
    "  HZ <- Z / zhat - (1 - Z) / (1 - zhat)\n",
    "  drZ <- yhat1 - yhat0 + (y - yhat) * HZ\n",
    "  drD <- dhat1 - dhat0 + (D - dhat) * HZ\n",
    "  coef_est <- mean(drZ) / mean(drD)\n",
    "  cat(\"point\", coef_est)\n",
    "  psi <- drZ - coef_est * drD\n",
    "  Jhat <- mean(drD)\n",
    "  variance <- mean(psi^2) / Jhat^2\n",
    "  se <- sqrt(variance / nrow(X))\n",
    "  cat(\"se\", se)\n",
    "\n",
    "  return(list(coef_est = coef_est, se = se, yhat = yhat, dhat = dhat, zhat = zhat, ytil = ytil,\n",
    "              dtil = dtil, ztil = ztil, drZ = drZ, drD = drD,\n",
    "              yhat0 = yhat0, yhat1 = yhat1, dhat0 = dhat0, dhat1 = dhat1))\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "51",
   "metadata": {
    "id": "iArB2WQHBXuV",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "summary_for_iivm <- function(coef_est, se, yhat, dhat, zhat, ytil, dtil, ztil, drZ, drD, X, Z, D, y, name) {\n",
    "  summary_data <- data.frame(\n",
    "    estimate = coef_est, # point estimate\n",
    "    se = se, # standard error\n",
    "    lower = coef_est - 1.96 * se, # lower end of 95% confidence interval\n",
    "    upper = coef_est + 1.96 * se, # upper end of 95% confidence interval\n",
    "    rmse_y = sqrt(mean(ytil^2)), # res of model that predicts outcome y\n",
    "    rmse_D = sqrt(mean(dtil^2)), # res of model that predicts treatment D\n",
    "    rmse_Z = sqrt(mean(ztil^2)), # res of model that predicts instrument Z\n",
    "    accuracy_D = mean(abs(dtil) < 0.5), # binary classification accuracy of model for D\n",
    "    accuracy_Z = mean(abs(ztil) < 0.5) # binary classification accuracy of model for Z\n",
    "  )\n",
    "  row.names(summary_data) <- name\n",
    "  return(summary_data)\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "52",
   "metadata": {
    "id": "Tj-8FFF3BXxV",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# DML with Lasso/Ridge\n",
    "set.seed(123)\n",
    "cat(sprintf(\"\\nDML with Lasso/Logistic \\n\"))\n",
    "# DML with Lasso/Ridge\n",
    "dreg0 <- function(x, d) {\n",
    "  cv.glmnet(x, d, family = \"binomial\", alpha = 0, nfolds = 5)\n",
    "}\n",
    "dreg1 <- function(x, d) {\n",
    "  cv.glmnet(x, d, family = \"binomial\", alpha = 0, nfolds = 5)\n",
    "}\n",
    "yreg0 <- function(x, y) {\n",
    "  cv.glmnet(x, y, family = \"gaussian\", alpha = 1, nfolds = 5)\n",
    "}\n",
    "yreg1 <- function(x, y) {\n",
    "  cv.glmnet(x, y, family = \"gaussian\", alpha = 1, nfolds = 5)\n",
    "}\n",
    "zreg <- function(x, z) {\n",
    "  cv.glmnet(x, z, family = \"binomial\", alpha = 0, nfolds = 5)\n",
    "}\n",
    "\n",
    "dml2_results <- dml2_for_iivm(as.matrix(X), D, Z, y, dreg0, dreg1, yreg0, yreg1, zreg,\n",
    "                              trimming = 0.01, nfold = 5, method = \"regression\")\n",
    "sum_lasso_ridge_cv <- summary_for_iivm(dml2_results$coef_est, dml2_results$se, dml2_results$yhat, dml2_results$dhat,\n",
    "                                       dml2_results$zhat, dml2_results$ytil, dml2_results$dtil, dml2_results$ztil,\n",
    "                                       dml2_results$drZ, dml2_results$drD, name = \"LassoCV/LogisticCV\")\n",
    "table <- data.frame()\n",
    "table <- rbind(table, sum_lasso_ridge_cv)\n",
    "table\n",
    "\n",
    "yhat_lasso <- dml2_results$yhat\n",
    "dhat_lasso <- dml2_results$dhat\n",
    "yhat0_lasso <- dml2_results$yhat0\n",
    "yhat1_lasso <- dml2_results$yhat1\n",
    "dhat0_lasso <- dml2_results$dhat0\n",
    "dhat1_lasso <- dml2_results$dhat1\n",
    "zhat_lasso <- dml2_results$zhat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "53",
   "metadata": {
    "id": "sXjbvMbEkYJd",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# DML with Random Forest\n",
    "set.seed(123)\n",
    "cat(sprintf(\"\\nDML with Random Forest \\n\"))\n",
    "\n",
    "dreg0 <- function(x, d) {\n",
    "  randomForest(x, d, ntree = 1000, nodesize = 10)\n",
    "} # ML method=Forest\n",
    "dreg1 <- function(x, d) {\n",
    "  randomForest(x, d, ntree = 1000, nodesize = 10)\n",
    "} # ML method=Forest\n",
    "yreg0 <- function(x, y) {\n",
    "  randomForest(x, y, ntree = 1000, nodesize = 10)\n",
    "} # ML method=Forest\n",
    "yreg1 <- function(x, y) {\n",
    "  randomForest(x, y, ntree = 1000, nodesize = 10)\n",
    "} # ML method=Forest\n",
    "zreg <- function(x, z) {\n",
    "  randomForest(x, z, ntree = 1000, nodesize = 10)\n",
    "} # ML method=Forest\n",
    "\n",
    "dml2_results <- dml2_for_iivm(X, D, Z, y, dreg0, dreg1, yreg0, yreg1, zreg,\n",
    "                              trimming = 0.01, nfold = 5, method = \"randomforest\")\n",
    "sum_rf <- summary_for_iivm(dml2_results$coef_est, dml2_results$se, dml2_results$yhat, dml2_results$dhat,\n",
    "                           dml2_results$zhat, dml2_results$ytil, dml2_results$dtil, dml2_results$ztil,\n",
    "                           dml2_results$drZ, dml2_results$drD, name = \"RF\")\n",
    "table <- rbind(table, sum_rf)\n",
    "table\n",
    "\n",
    "yhat_rf <- dml2_results$yhat\n",
    "dhat_rf <- dml2_results$dhat\n",
    "yhat0_rf <- dml2_results$yhat0\n",
    "yhat1_rf <- dml2_results$yhat1\n",
    "dhat0_rf <- dml2_results$dhat0\n",
    "dhat1_rf <- dml2_results$dhat1\n",
    "zhat_rf <- dml2_results$zhat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "54",
   "metadata": {
    "id": "ZZRXpY8YkYNN",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# DML with Decision Trees\n",
    "set.seed(123)\n",
    "cat(sprintf(\"\\nDML with Decision Trees \\n\"))\n",
    "\n",
    "dreg0 <- function(x, d) {\n",
    "  rpart(as.formula(\"D ~ .\"), cbind(data.frame(D = d), x), method = \"class\", minbucket = 10, cp = 0.001)\n",
    "}\n",
    "dreg1 <- function(x, d) {\n",
    "  rpart(as.formula(\"D ~ .\"), cbind(data.frame(D = d), x), method = \"class\", minbucket = 10, cp = 0.001)\n",
    "}\n",
    "yreg0 <- function(x, y) {\n",
    "  rpart(as.formula(\"y ~ .\"), cbind(data.frame(y = y), x), minbucket = 10, cp = 0.001)\n",
    "}\n",
    "yreg1 <- function(x, y) {\n",
    "  rpart(as.formula(\"y ~ .\"), cbind(data.frame(y = y), x), minbucket = 10, cp = 0.001)\n",
    "}\n",
    "zreg <- function(x, z) {\n",
    "  rpart(as.formula(\"Z ~ .\"), cbind(data.frame(Z = z), x), method = \"class\", minbucket = 10, cp = 0.001)\n",
    "}\n",
    "\n",
    "dml2_results <- dml2_for_iivm(X, D, Z, y, dreg0, dreg1, yreg0, yreg1, zreg,\n",
    "                              trimming = 0.01, nfold = 5, method = \"decisiontrees\")\n",
    "sum_tr <- summary_for_iivm(dml2_results$coef_est, dml2_results$se, dml2_results$yhat, dml2_results$dhat,\n",
    "                           dml2_results$zhat, dml2_results$ytil, dml2_results$dtil, dml2_results$ztil,\n",
    "                           dml2_results$drZ, dml2_results$drD, name = \"Decision Trees\")\n",
    "table <- rbind(table, sum_tr)\n",
    "table\n",
    "\n",
    "yhat_tr <- dml2_results$yhat\n",
    "dhat_tr <- dml2_results$dhat\n",
    "yhat0_tr <- dml2_results$yhat0\n",
    "yhat1_tr <- dml2_results$yhat1\n",
    "dhat0_tr <- dml2_results$dhat0\n",
    "dhat1_tr <- dml2_results$dhat1\n",
    "zhat_tr <- dml2_results$zhat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "55",
   "metadata": {
    "id": "RYqykjPskYQJ",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# DML with Boosted Trees\n",
    "set.seed(123)\n",
    "cat(sprintf(\"\\nDML with Boosted Trees \\n\"))\n",
    "\n",
    "# NB: early stopping cannot easily be implemented with gbm\n",
    "## set n.trees = best, where best <- gbm.perf(dreg_boost, plot.it = FALSE)\n",
    "dreg0 <- function(x, d) {\n",
    "  gbm(as.formula(\"D ~ .\"), cbind(data.frame(D = d), x), distribution = \"bernoulli\",\n",
    "      interaction.depth = 2, n.trees = 100, shrinkage = .1)\n",
    "}\n",
    "dreg1 <- function(x, d) {\n",
    "  gbm(as.formula(\"D ~ .\"), cbind(data.frame(D = d), x), distribution = \"bernoulli\",\n",
    "      interaction.depth = 2, n.trees = 100, shrinkage = .1)\n",
    "}\n",
    "yreg0 <- function(x, y) {\n",
    "  gbm(as.formula(\"y ~ .\"), cbind(data.frame(y = y), x), distribution = \"gaussian\",\n",
    "      interaction.depth = 2, n.trees = 100, shrinkage = .1)\n",
    "}\n",
    "yreg1 <- function(x, y) {\n",
    "  gbm(as.formula(\"y ~ .\"), cbind(data.frame(y = y), x), distribution = \"gaussian\",\n",
    "      interaction.depth = 2, n.trees = 100, shrinkage = .1)\n",
    "}\n",
    "zreg <- function(x, z) {\n",
    "  gbm(as.formula(\"Z ~ .\"), cbind(data.frame(Z = z), x), distribution = \"bernoulli\",\n",
    "      interaction.depth = 2, n.trees = 100, shrinkage = .1)\n",
    "}\n",
    "\n",
    "# passing these through regression as type=\"response\", and D and Z should not be factors!\n",
    "dml2_results <- dml2_for_iivm(X, D, Z, y, dreg0, dreg1, yreg0, yreg1, zreg,\n",
    "                              trimming = 0.01, nfold = 5, method = \"boostedtrees\")\n",
    "sum_boost <- summary_for_iivm(dml2_results$coef_est, dml2_results$se, dml2_results$yhat, dml2_results$dhat,\n",
    "                              dml2_results$zhat, dml2_results$ytil, dml2_results$dtil, dml2_results$ztil,\n",
    "                              dml2_results$drZ, dml2_results$drD, name = \"Boosted Trees\")\n",
    "table <- rbind(table, sum_boost)\n",
    "table\n",
    "\n",
    "yhat_boost <- dml2_results$yhat\n",
    "dhat_boost <- dml2_results$dhat\n",
    "yhat0_boost <- dml2_results$yhat0\n",
    "yhat1_boost <- dml2_results$yhat1\n",
    "dhat0_boost <- dml2_results$dhat0\n",
    "dhat1_boost <- dml2_results$dhat1\n",
    "zhat_boost <- dml2_results$zhat"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "56",
   "metadata": {
    "id": "29vcyCYsktQ3"
   },
   "source": [
    "## Ensembles"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "57",
   "metadata": {
    "id": "vuyfd9UJkw9G"
   },
   "source": [
    "Boosted trees give the best RMSE for D and Z and random forests give the best RMSE for Y."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "58",
   "metadata": {
    "id": "Y9_T5SMUk3Rd",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# Best fit is boosted trees for D, Z and random forests for Y\n",
    "\n",
    "best_yhat0 <- yhat0_rf\n",
    "best_yhat1 <- yhat1_rf\n",
    "best_yhat <- yhat_rf\n",
    "\n",
    "best_dhat0 <- dhat0_boost\n",
    "best_dhat1 <- dhat1_boost\n",
    "best_dhat <- dhat_boost\n",
    "\n",
    "best_zhat <- zhat_boost\n",
    "\n",
    "ytil_best <- y - best_yhat\n",
    "dtil_best <- D - best_dhat\n",
    "ztil_best <- Z - best_zhat\n",
    "\n",
    "# doubly robust quantity for every sample\n",
    "HZ <- Z / best_zhat - (1 - Z) / (1 - best_zhat)\n",
    "drZ <- best_yhat1 - best_yhat0 + (y - best_yhat) * HZ\n",
    "drD <- best_dhat1 - best_dhat0 + (D - best_dhat) * HZ\n",
    "coef_est <- mean(drZ) / mean(drD)\n",
    "psi <- drZ - coef_est * drD\n",
    "Jhat <- mean(drD)\n",
    "variance <- mean(psi^2) / Jhat^2\n",
    "se <- sqrt(variance / nrow(X))\n",
    "\n",
    "sum_best <- summary_for_iivm(coef_est, se, best_yhat, best_dhat, best_zhat,\n",
    "                             ytil_best, dtil_best, ztil_best, drZ, drD, name = \"Best\")\n",
    "table <- rbind(table, sum_best)\n",
    "table"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "59",
   "metadata": {
    "id": "RyRS9zNUlMCF"
   },
   "source": [
    "We'll form a model average with unconstrained least squares weights."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "60",
   "metadata": {
    "id": "1H4sCbO2lLpJ",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# Least squares model average\n",
    "ma_dcoef <- lm(D ~ dhat_lasso + dhat_rf + dhat_tr + dhat_boost - 1)$coef\n",
    "ma_ycoef <- lm(y ~ yhat_lasso + yhat_rf + yhat_tr + yhat_boost - 1)$coef\n",
    "ma_zcoef <- lm(Z ~ zhat_lasso + zhat_rf + zhat_tr + zhat_boost - 1)$coef\n",
    "\n",
    "ma_yhat0 <- cbind(yhat0_lasso, yhat0_rf, yhat0_tr, yhat0_boost) %*% as.matrix(ma_ycoef)\n",
    "ma_yhat1 <- cbind(yhat1_lasso, yhat1_rf, yhat1_tr, yhat1_boost) %*% as.matrix(ma_ycoef)\n",
    "ma_dhat0 <- cbind(dhat0_lasso, dhat0_rf, dhat0_tr, dhat0_boost) %*% as.matrix(ma_dcoef)\n",
    "ma_dhat1 <- cbind(dhat1_lasso, dhat1_rf, dhat1_tr, dhat1_boost) %*% as.matrix(ma_dcoef)\n",
    "ma_zhat <- cbind(zhat_lasso, zhat_rf, zhat_tr, zhat_boost) %*% as.matrix(ma_zcoef)\n",
    "\n",
    "# Prediction of treatment and outcome for observed instrument\n",
    "ma_yhat <- ma_yhat0 * (1 - Z) + ma_yhat1 * Z\n",
    "ma_dhat <- ma_dhat0 * (1 - Z) + ma_dhat1 * Z\n",
    "\n",
    "# residuals\n",
    "ma_ytil <- y - ma_yhat\n",
    "ma_dtil <- D - ma_dhat\n",
    "ma_ztil <- Z - ma_zhat\n",
    "\n",
    "# doubly robust quantity for every sample\n",
    "HZ <- Z / ma_zhat - (1 - Z) / (1 - ma_zhat)\n",
    "drZ <- ma_yhat1 - ma_yhat0 + (y - ma_yhat) * HZ\n",
    "drD <- ma_dhat1 - ma_dhat0 + (D - ma_dhat) * HZ\n",
    "coef_est <- mean(drZ) / mean(drD)\n",
    "psi <- drZ - coef_est * drD\n",
    "Jhat <- mean(drD)\n",
    "variance <- mean(psi^2) / Jhat^2\n",
    "se <- sqrt(variance / nrow(X))\n",
    "\n",
    "sum_ma <- summary_for_iivm(coef_est, se, ma_yhat, ma_dhat, ma_zhat,\n",
    "                           ma_ytil, ma_dtil, ma_ztil, drZ, drD, name = \"Model Average\")\n",
    "table <- rbind(table, sum_ma)\n",
    "table"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "61",
   "metadata": {
    "id": "UflbjTEG5SXV"
   },
   "source": [
    "Comparing with the PLR model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "62",
   "metadata": {
    "id": "CIS-58oi4sa1",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "tableplr"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "63",
   "metadata": {
    "id": "M4Zi0FPH5VZG"
   },
   "source": [
    "We find that the PLR model overestimates the effect by around 1k; though both sets of results have overlapping confidence intervals."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "64",
   "metadata": {
    "id": "VrBkj_pc5qgm"
   },
   "source": [
    "\n",
    "Again as before, ideally we would do (semi) cross-fitting with AutoML in order to find good first-stage models and re-run DML with these models. Unfortunately this is not easy to do in R.\n",
    "\n",
    "As before, in the below analysis of robust inference, we choose Boosted Trees as they perform well in RMSE and accuracy on first-stage models."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "65",
   "metadata": {
    "id": "bj67nsgcCDoS",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "iivm_robust_inference <- function(point, stderr, yhat, Dhat, Zhat, resy, resD, resZ,\n",
    "                                  drZ, drD, X, Z, D, y, grid, alpha = 0.05) {\n",
    "  # Inference in the partially linear IV model that is robust to weak identification.\n",
    "  # grid: grid of theta values to search over when trying to identify the confidence region\n",
    "  # alpha: confidence level\n",
    "\n",
    "  n <- dim(X)[1]\n",
    "  thr <- qchisq(1 - alpha, df = 1)\n",
    "  accept <- c()\n",
    "\n",
    "  for (theta in grid) {\n",
    "    moment <- drZ - theta * drD\n",
    "    test <- n * mean(moment)^2 / var(moment)\n",
    "    if (test <= thr) {\n",
    "      accept <- c(accept, theta)\n",
    "    }\n",
    "  }\n",
    "\n",
    "  return(accept)\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "66",
   "metadata": {
    "id": "KqgPk1Jm4sdo",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "grid <- seq(0, 20000, length.out = 10000)\n",
    "region <- iivm_robust_inference(point = dml2_results$coef_est, stderr = dml2_results$se,\n",
    "                                yhat = dml2_results$yhat, Dhat = dml2_results$dhat, Zhat = dml2_results$zhat,\n",
    "                                resy = dml2_results$ytil, resD = dml2_results$dtil, resZ = dml2_results$ztil,\n",
    "                                drZ = dml2_results$drZ, drD = dml2_results$drD,\n",
    "                                X = X, Z = Z, D = D, y = y, grid = grid)\n",
    "\n",
    "# Calculate min and max\n",
    "min_region <- min(region)\n",
    "max_region <- max(region)\n",
    "\n",
    "print(min_region)\n",
    "print(max_region)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "67",
   "metadata": {
    "id": "akCGDMZJCN3h"
   },
   "source": [
    "We find again that the robust inference confidence region is almost identical to the normal based inference. We are most probably in the strong instrument regime. We can check the t-statistic for the effect of the instrument on the treatment to verify this."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "68",
   "metadata": {
    "id": "01de9f24",
    "papermill": {
     "duration": 0.010725,
     "end_time": "2022-04-19T09:06:51.098483",
     "exception": false,
     "start_time": "2022-04-19T09:06:51.087758",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# DoubleML package\n",
    "\n",
    "There exist nice packages out there that can help us do our estimation with the simple call of a function. Such packages include `EconML` (Python) and `DoubleML` (Python and R).\n",
    "\n",
    "We run through IIVM using `DoubleML` below to illustrate. The `DoubleML` package internally builds on `mlr3`. We use the meta package `mlr3` to generate predictions with machine learning methods. A comprehensive introduction and description of the `mlr3` package is provided in the [mlr3book](https://mlr3book.mlr-org.com/). A list of all learners that you can use in `mlr3` can be found [here](https://mlr3extralearners.mlr-org.com/articles/learners/list_learners.html). The entry in the columns *mlr3 Package* and *Packages* indicate which packages must be installed/loaded in your R session.\n",
    "\n",
    "You find additional information about `DoubleML` on the package on the package website https://docs.doubleml.org/ and the R documentation page https://docs.doubleml.org/r/stable/."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "69",
   "metadata": {
    "id": "2846a36a",
    "papermill": {
     "duration": 20.239271,
     "end_time": "2022-04-19T09:07:11.369618",
     "exception": false,
     "start_time": "2022-04-19T09:06:51.130347",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "install.packages(\"DoubleML\")\n",
    "install.packages(\"mlr3learners\")\n",
    "install.packages(\"mlr3\")\n",
    "install.packages(\"data.table\")\n",
    "install.packages(\"ranger\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "70",
   "metadata": {
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "library(DoubleML)\n",
    "library(mlr3learners)\n",
    "library(mlr3)\n",
    "library(data.table)\n",
    "library(ranger)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "71",
   "metadata": {
    "id": "2259ae1c",
    "papermill": {
     "duration": 0.015455,
     "end_time": "2022-04-19T09:12:00.920079",
     "exception": false,
     "start_time": "2022-04-19T09:12:00.904624",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Local Average Treatment Effects of 401(k) Participation on Net Financial Assets"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "72",
   "metadata": {
    "id": "9c27e413",
    "papermill": {
     "duration": 0.015158,
     "end_time": "2022-04-19T09:12:00.950542",
     "exception": false,
     "start_time": "2022-04-19T09:12:00.935384",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Interactive IV Model (IIVM)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "73",
   "metadata": {
    "id": "4fa23c70",
    "papermill": {
     "duration": 0.015304,
     "end_time": "2022-04-19T09:12:00.981285",
     "exception": false,
     "start_time": "2022-04-19T09:12:00.965981",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Now, we consider estimation of local average treatment effects (LATE) of participation with the binary instrument `e401`. As before, $Y$ denotes the outcome `net_tfa`, and $X$ is the vector of covariates.  Here the structural equation model is:\n",
    "\n",
    "\\begin{align}\n",
    "Y :=~& g_0(Z,X) + U, &\\quad E[U\\mid Z,X] = 0,\\\\\n",
    "D :=~& r_0(Z,X) + V, &\\quad E[V\\mid Z, X] = 0,\\\\\n",
    "Z :=~& m_0(X) + \\zeta, &\\quad E[\\zeta \\mid X] = 0.\n",
    "\\end{align}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "74",
   "metadata": {
    "id": "cb223b75",
    "papermill": {
     "duration": 0.06823,
     "end_time": "2022-04-19T09:12:01.064957",
     "exception": false,
     "start_time": "2022-04-19T09:12:00.996727",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# Constructing the data (as DoubleMLData)\n",
    "formula_flex2 <- paste(\"net_tfa ~ p401+ e401 + poly(age, 6, raw=TRUE) + poly(inc, 8, raw=TRUE) + \",\n",
    "                       \"poly(educ, 4, raw=TRUE) + poly(fsize, 2, raw=TRUE) + male + marr + twoearn + db + pira + hown\")\n",
    "model_flex2 <- as.data.table(model.frame(formula_flex2, data))\n",
    "x_cols <- colnames(model_flex2)[-c(1, 2, 3)]\n",
    "data_iv <- DoubleMLData$new(model_flex2, y_col = \"net_tfa\", d_cols = \"p401\", z_cols = \"e401\", x_cols = x_cols)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "75",
   "metadata": {
    "id": "e652ffad",
    "papermill": {
     "duration": 20.934595,
     "end_time": "2022-04-19T09:12:22.014866",
     "exception": false,
     "start_time": "2022-04-19T09:12:01.080271",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "lgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\n",
    "lasso <- lrn(\"regr.cv_glmnet\", nfolds = 5, s = \"lambda.min\")\n",
    "lasso_class <- lrn(\"classif.cv_glmnet\", nfolds = 5, s = \"lambda.min\")\n",
    "dml_mliivm <- DoubleMLIIVM$new(data_iv,\n",
    "  ml_g = lasso,\n",
    "  ml_m = lasso_class, ml_r = lasso_class, n_folds = 5, subgroups = list(\n",
    "    always_takers = FALSE,\n",
    "    never_takers = TRUE\n",
    "  )\n",
    ")\n",
    "dml_mliivm$fit(store_predictions = TRUE)\n",
    "dml_mliivm$summary()\n",
    "lasso_mliivm <- dml_mliivm$coef\n",
    "lasso_std_mliivm <- dml_mliivm$se"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "76",
   "metadata": {
    "id": "63103667",
    "papermill": {
     "duration": 0.015382,
     "end_time": "2022-04-19T09:12:22.045989",
     "exception": false,
     "start_time": "2022-04-19T09:12:22.030607",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "The confidence interval for the local average treatment effect of participation is given by"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "77",
   "metadata": {
    "id": "322855c4",
    "papermill": {
     "duration": 0.042067,
     "end_time": "2022-04-19T09:12:22.103953",
     "exception": false,
     "start_time": "2022-04-19T09:12:22.061886",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "dml_mliivm$confint(level = 0.95)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "78",
   "metadata": {
    "id": "2965410d",
    "papermill": {
     "duration": 0.015374,
     "end_time": "2022-04-19T09:12:22.134875",
     "exception": false,
     "start_time": "2022-04-19T09:12:22.119501",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Here we can also check the accuracy of the model:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "79",
   "metadata": {
    "id": "1476fd27",
    "papermill": {
     "duration": 0.056054,
     "end_time": "2022-04-19T09:12:22.206157",
     "exception": false,
     "start_time": "2022-04-19T09:12:22.150103",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# variables\n",
    "y <- as.matrix(pension$net_tfa) # true observations\n",
    "d <- as.matrix(pension$p401)\n",
    "z <- as.matrix(pension$e401)\n",
    "\n",
    "# predictions\n",
    "dml_mliivm$params_names()\n",
    "g0_hat <- as.matrix(dml_mliivm$predictions$ml_g0) # predictions of g_0(z=0, X)\n",
    "g1_hat <- as.matrix(dml_mliivm$predictions$ml_g1) # predictions of g_0(z=1, X)\n",
    "g_hat <- z * g1_hat + (1 - z) * g0_hat # predictions of g_0\n",
    "r0_hat <- as.matrix(dml_mliivm$predictions$ml_r0) # predictions of r_0(z=0, X)\n",
    "r1_hat <- as.matrix(dml_mliivm$predictions$ml_r1) # predictions of r_0(z=1, X)\n",
    "r_hat <- z * r1_hat + (1 - z) * r0_hat # predictions of r_0\n",
    "m_hat <- as.matrix(dml_mliivm$predictions$ml_m) # predictions of m_o"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "80",
   "metadata": {
    "id": "444c53f4",
    "papermill": {
     "duration": 0.056945,
     "end_time": "2022-04-19T09:12:22.278593",
     "exception": false,
     "start_time": "2022-04-19T09:12:22.221648",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# cross-fitted RMSE: outcome\n",
    "lasso_y_mliivm <- sqrt(mean((y - g_hat)^2))\n",
    "lasso_y_mliivm\n",
    "\n",
    "# cross-fitted RMSE: treatment\n",
    "lasso_d_mliivm <- sqrt(mean((d - r_hat)^2))\n",
    "lasso_d_mliivm\n",
    "\n",
    "# cross-fitted RMSE: instrument\n",
    "lasso_z_mliivm <- sqrt(mean((z - m_hat)^2))\n",
    "lasso_z_mliivm"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "81",
   "metadata": {
    "id": "a7461966",
    "papermill": {
     "duration": 0.016468,
     "end_time": "2022-04-19T09:12:22.311250",
     "exception": false,
     "start_time": "2022-04-19T09:12:22.294782",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "Again, we repeat the procedure for the other machine learning methods:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "82",
   "metadata": {
    "id": "59YzwIcpEnyV",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# needed to run boosting\n",
    "remotes::install_github(\"mlr-org/mlr3extralearners\")\n",
    "install.packages(\"mlr3extralearners\")\n",
    "install.packages(\"mboost\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "83",
   "metadata": {
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "library(mlr3extralearners)\n",
    "library(mboost)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "84",
   "metadata": {
    "id": "Ec0g3ch3EjAl",
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "# Forest\n",
    "randomForest <- lrn(\"regr.ranger\")\n",
    "random_forest_class <- lrn(\"classif.ranger\")\n",
    "\n",
    "# Trees\n",
    "trees <- lrn(\"regr.rpart\")\n",
    "trees_class <- lrn(\"classif.rpart\")\n",
    "\n",
    "# Boosting\n",
    "boost <- lrn(\"regr.glmboost\")\n",
    "boost_class <- lrn(\"classif.glmboost\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "85",
   "metadata": {
    "id": "3935dfc5",
    "papermill": {
     "duration": 69.414354,
     "end_time": "2022-04-19T09:13:31.742249",
     "exception": false,
     "start_time": "2022-04-19T09:12:22.327895",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "### random forest ###\n",
    "\n",
    "lgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\n",
    "dml_mliivm <- DoubleMLIIVM$new(data_iv,\n",
    "  ml_g = randomForest,\n",
    "  ml_m = random_forest_class, ml_r = random_forest_class, n_folds = 3, subgroups = list(\n",
    "    always_takers = FALSE,\n",
    "    never_takers = TRUE\n",
    "  )\n",
    ")\n",
    "dml_mliivm$fit(store_predictions = TRUE)\n",
    "dml_mliivm$summary()\n",
    "forest_mliivm <- dml_mliivm$coef\n",
    "forest_std_mliivm <- dml_mliivm$se\n",
    "\n",
    "# predictions\n",
    "g0_hat <- as.matrix(dml_mliivm$predictions$ml_g0) # predictions of g_0(Z=0, X)\n",
    "g1_hat <- as.matrix(dml_mliivm$predictions$ml_g1) # predictions of g_0(Z=1, X)\n",
    "g_hat <- z * g1_hat + (1 - z) * g0_hat # predictions of g_0\n",
    "r0_hat <- as.matrix(dml_mliivm$predictions$ml_r0) # predictions of r_0(Z=0, X)\n",
    "r1_hat <- as.matrix(dml_mliivm$predictions$ml_r1) # predictions of r_0(Z=1, X)\n",
    "r_hat <- z * r1_hat + (1 - z) * r0_hat # predictions of r_0\n",
    "m_hat <- as.matrix(dml_mliivm$predictions$ml_m) # predictions of m_o\n",
    "\n",
    "# cross-fitted RMSE: outcome\n",
    "forest_y_mliivm <- sqrt(mean((y - g_hat)^2))\n",
    "forest_y_mliivm\n",
    "\n",
    "# cross-fitted RMSE: treatment\n",
    "forest_d_mliivm <- sqrt(mean((d - r_hat)^2))\n",
    "forest_d_mliivm\n",
    "\n",
    "# cross-fitted RMSE: instrument\n",
    "forest_z_mliivm <- sqrt(mean((z - m_hat)^2))\n",
    "forest_z_mliivm\n",
    "\n",
    "### trees ###\n",
    "\n",
    "dml_mliivm <- DoubleMLIIVM$new(data_iv,\n",
    "  ml_g = trees,\n",
    "  ml_m = trees_class, ml_r = trees_class, n_folds = 3, subgroups = list(\n",
    "    always_takers = FALSE,\n",
    "    never_takers = TRUE\n",
    "  )\n",
    ")\n",
    "dml_mliivm$fit(store_predictions = TRUE)\n",
    "dml_mliivm$summary()\n",
    "tree_mliivm <- dml_mliivm$coef\n",
    "tree_std_mliivm <- dml_mliivm$se\n",
    "\n",
    "# predictions\n",
    "g0_hat <- as.matrix(dml_mliivm$predictions$ml_g0) # predictions of g_0(Z=0, X)\n",
    "g1_hat <- as.matrix(dml_mliivm$predictions$ml_g1) # predictions of g_0(Z=1, X)\n",
    "g_hat <- z * g1_hat + (1 - z) * g0_hat # predictions of g_0\n",
    "r0_hat <- as.matrix(dml_mliivm$predictions$ml_r0) # predictions of r_0(Z=0, X)\n",
    "r1_hat <- as.matrix(dml_mliivm$predictions$ml_r1) # predictions of r_0(Z=1, X)\n",
    "r_hat <- z * r1_hat + (1 - z) * r0_hat # predictions of r_0\n",
    "m_hat <- as.matrix(dml_mliivm$predictions$ml_m) # predictions of m_o\n",
    "\n",
    "# cross-fitted RMSE: outcome\n",
    "tree_y_mliivm <- sqrt(mean((y - g_hat)^2))\n",
    "tree_y_mliivm\n",
    "\n",
    "# cross-fitted RMSE: treatment\n",
    "tree_d_mliivm <- sqrt(mean((d - r_hat)^2))\n",
    "tree_d_mliivm\n",
    "\n",
    "# cross-fitted RMSE: instrument\n",
    "tree_z_mliivm <- sqrt(mean((z - m_hat)^2))\n",
    "tree_z_mliivm\n",
    "\n",
    "\n",
    "### boosting ###\n",
    "dml_mliivm <- DoubleMLIIVM$new(data_iv,\n",
    "  ml_g = boost,\n",
    "  ml_m = boost_class, ml_r = boost_class, n_folds = 3, subgroups = list(\n",
    "    always_takers = FALSE,\n",
    "    never_takers = TRUE\n",
    "  )\n",
    ")\n",
    "dml_mliivm$fit(store_predictions = TRUE)\n",
    "dml_mliivm$summary()\n",
    "boost_mliivm <- dml_mliivm$coef\n",
    "boost_std_mliivm <- dml_mliivm$se\n",
    "\n",
    "# predictions\n",
    "g0_hat <- as.matrix(dml_mliivm$predictions$ml_g0) # predictions of g_0(Z=0, X)\n",
    "g1_hat <- as.matrix(dml_mliivm$predictions$ml_g1) # predictions of g_0(Z=1, X)\n",
    "g_hat <- z * g1_hat + (1 - z) * g0_hat # predictions of g_0\n",
    "r0_hat <- as.matrix(dml_mliivm$predictions$ml_r0) # predictions of r_0(Z=0, X)\n",
    "r1_hat <- as.matrix(dml_mliivm$predictions$ml_r1) # predictions of r_0(Z=1, X)\n",
    "r_hat <- z * r1_hat + (1 - z) * r0_hat # predictions of r_0\n",
    "m_hat <- as.matrix(dml_mliivm$predictions$ml_m) # predictions of m_o\n",
    "\n",
    "# cross-fitted RMSE: outcome\n",
    "boost_y_mliivm <- sqrt(mean((y - g_hat)^2))\n",
    "boost_y_mliivm\n",
    "\n",
    "# cross-fitted RMSE: treatment\n",
    "boost_d_mliivm <- sqrt(mean((d - r_hat)^2))\n",
    "boost_d_mliivm\n",
    "\n",
    "# cross-fitted RMSE: instrument\n",
    "boost_z_mliivm <- sqrt(mean((z - m_hat)^2))\n",
    "boost_z_mliivm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "86",
   "metadata": {
    "id": "7187fc74",
    "papermill": {
     "duration": 0.061872,
     "end_time": "2022-04-19T09:13:31.824148",
     "exception": false,
     "start_time": "2022-04-19T09:13:31.762276",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "table <- matrix(0, 5, 4)\n",
    "table[1, 1:4] <- c(lasso_mliivm, forest_mliivm, tree_mliivm, boost_mliivm)\n",
    "table[2, 1:4] <- c(lasso_std_mliivm, forest_std_mliivm, tree_std_mliivm, boost_std_mliivm)\n",
    "table[3, 1:4] <- c(lasso_y_mliivm, forest_y_mliivm, tree_y_mliivm, boost_y_mliivm)\n",
    "table[4, 1:4] <- c(lasso_d_mliivm, forest_d_mliivm, tree_d_mliivm, boost_d_mliivm)\n",
    "table[5, 1:4] <- c(lasso_z_mliivm, forest_z_mliivm, tree_z_mliivm, boost_z_mliivm)\n",
    "rownames(table) <- c(\"Estimate\", \"Std.Error\", \"RMSE Y\", \"RMSE D\", \"RMSE Z\")\n",
    "colnames(table) <- c(\"Lasso\", \"Random Forest\", \"Trees\", \"Boosting\")\n",
    "tab <- xtable(table, digits = 2)\n",
    "tab"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "87",
   "metadata": {
    "id": "f4ce7be1",
    "papermill": {
     "duration": 0.017437,
     "end_time": "2022-04-19T09:13:31.859052",
     "exception": false,
     "start_time": "2022-04-19T09:13:31.841615",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "We report results based on four ML methods for estimating the nuisance functions used in\n",
    "forming the orthogonal estimating equations. We find again that the estimates of the treatment effect are stable across ML methods. The estimates are highly significant, hence we would reject the hypothesis\n",
    "that the effect of 401(k) participation has no effect on financial health."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "88",
   "metadata": {
    "id": "4939cd9c",
    "papermill": {
     "duration": 0.017163,
     "end_time": "2022-04-19T09:13:31.893361",
     "exception": false,
     "start_time": "2022-04-19T09:13:31.876198",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "We might rerun the model using the best ML method for each equation to get a final estimate for the treatment effect of participation:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "89",
   "metadata": {
    "id": "ca612b71",
    "papermill": {
     "duration": 20.780029,
     "end_time": "2022-04-19T09:13:52.690594",
     "exception": false,
     "start_time": "2022-04-19T09:13:31.910565",
     "status": "completed"
    },
    "tags": [],
    "vscode": {
     "languageId": "r"
    }
   },
   "outputs": [],
   "source": [
    "lgr::get_logger(\"mlr3\")$set_threshold(\"warn\")\n",
    "dml_mliivm <- DoubleMLIIVM$new(data_iv,\n",
    "  ml_g = randomForest,\n",
    "  ml_m = lasso_class, ml_r = lasso_class, n_folds = 5, subgroups = list(\n",
    "    always_takers = FALSE,\n",
    "    never_takers = TRUE\n",
    "  )\n",
    ")\n",
    "dml_mliivm$fit(store_predictions = TRUE)\n",
    "dml_mliivm$summary()\n",
    "best_mliivm <- dml_mliivm$coef\n",
    "best_std_mliivm <- dml_mliivm$se"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "provenance": []
  },
  "kernelspec": {
   "display_name": "R",
   "language": "R",
   "name": "ir"
  },
  "language_info": {
   "codemirror_mode": "r",
   "file_extension": ".r",
   "mimetype": "text/x-r-source",
   "name": "R",
   "pygments_lexer": "r",
   "version": "4.0.5"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 427.936706,
   "end_time": "2022-04-19T09:13:53.230849",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2022-04-19T09:06:45.294143",
   "version": "2.3.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
